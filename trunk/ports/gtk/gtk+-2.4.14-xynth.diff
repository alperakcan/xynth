diff -Naur gtk+-2.4.14/README.xynth gtk+-2.4.14-xynth/README.xynth
--- gtk+-2.4.14/README.xynth	1970-01-01 02:00:00.000000000 +0200
+++ gtk+-2.4.14-xynth/README.xynth	2006-12-12 13:00:51.000000000 +0200
@@ -0,0 +1,34 @@
+Xynth gtk+-2.4.14 patch
+
+This port's aim is to show that widget libraries can be easily ported to xynth. 
+First we want to say "We are NOT guru of gtk or gdk."
+
+Xynth port is heavily based on linux framebuffer port of gtk. As you might know
+linux framebuffer is not  working properly in 2.6.x kernel. Also linux 
+framebuffer port of gtk is not supporting multiple gtk applications (clients).
+
+The advantages of Xynth port is lying on these. By using xynth port you can get
+gtk on sdl, vesa, svga and also you can get multiple gtk applications at 
+the same time that is already a windowing system must.
+
+New patches are welcome
+
+How to install:
+
+1- apply the patch
+
+cp gtk+-2.4.14-xynth.diff gtk+-2.4.14/
+cd gtk+-2.4.14
+patch -p1 < gtk+-2.4.14-xynth.diff
+
+2- pass --with-gdktarget=linux-fb option to the configure script and also 
+its better to use prefix not to conflict with other version of gtk library
+
+3- add your prefix library or default /usr/local/lib to ld.so.conf 
+
+4- ldconfig
+
+Than compile your gtk program as usual. You may try demo and tests within the 
+gtk+-2.4.14.
+
+Xynth Team
\ No newline at end of file
diff -Naur gtk+-2.4.14/gdk/Makefile.am gtk+-2.4.14-xynth/gdk/Makefile.am
--- gtk+-2.4.14/gdk/Makefile.am	2003-12-10 15:49:52.000000000 +0200
+++ gtk+-2.4.14-xynth/gdk/Makefile.am	2006-12-12 13:00:51.000000000 +0200
@@ -131,7 +131,7 @@
 
 libgdk_linux_fb_2_0_la_SOURCES = $(common_sources) gdkkeynames.c
 libgdk_linux_fb_2_0_la_LIBADD = linux-fb/libgdk-linux-fb.la $(GDK_DEP_LIBS) \
-  $(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la
+  $(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la -lxynth
 libgdk_linux_fb_2_0_la_LDFLAGS = $(LDADD)
 
 libgdk_win32_2_0_la_SOURCES = $(common_sources) gdkkeynames.c
diff -Naur gtk+-2.4.14/gdk/Makefile.in gtk+-2.4.14-xynth/gdk/Makefile.in
--- gtk+-2.4.14/gdk/Makefile.in	2004-12-03 05:55:46.000000000 +0200
+++ gtk+-2.4.14-xynth/gdk/Makefile.in	2006-12-12 13:00:51.000000000 +0200
@@ -412,7 +412,7 @@
 
 libgdk_linux_fb_2_0_la_SOURCES = $(common_sources) gdkkeynames.c
 libgdk_linux_fb_2_0_la_LIBADD = linux-fb/libgdk-linux-fb.la $(GDK_DEP_LIBS) \
-  $(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la
+  $(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la -lxynth
 
 libgdk_linux_fb_2_0_la_LDFLAGS = $(LDADD)
 
diff -Naur gtk+-2.4.14/gdk/linux-fb/gdkcursor-fb.c gtk+-2.4.14-xynth/gdk/linux-fb/gdkcursor-fb.c
--- gtk+-2.4.14/gdk/linux-fb/gdkcursor-fb.c	2004-03-06 05:37:04.000000000 +0200
+++ gtk+-2.4.14-xynth/gdk/linux-fb/gdkcursor-fb.c	2006-12-12 12:48:04.000000000 +0200
@@ -288,251 +288,41 @@
   g_free (private);
 }
 
-/* Global data to keep track of cursor */
-static GdkPixmap *last_contents = NULL;
-static GdkPoint last_location, last_contents_size;
-static GdkCursor *last_cursor = NULL;
-static GdkFBDrawingContext *gdk_fb_cursor_dc = NULL;
-static GdkFBDrawingContext cursor_dc_dat;
-static GdkGC *cursor_gc;
-static gint cursor_visibility_count = 1;
-
-static GdkFBDrawingContext *
-gdk_fb_cursor_dc_reset (void)
-{
-  if (gdk_fb_cursor_dc)
-    gdk_fb_drawing_context_finalize (gdk_fb_cursor_dc);
-
-  gdk_fb_cursor_dc = &cursor_dc_dat;
-  gdk_fb_drawing_context_init (gdk_fb_cursor_dc,
-			       GDK_DRAWABLE_IMPL(_gdk_parent_root),
-			       cursor_gc,
-			       TRUE,
-			       FALSE);
-
-  return gdk_fb_cursor_dc;
-}
-
-void
-gdk_fb_cursor_hide (void)
-{
-  GdkFBDrawingContext *mydc = gdk_fb_cursor_dc;
-
-  cursor_visibility_count--;
-  g_assert (cursor_visibility_count <= 0);
-  
-  if (cursor_visibility_count < 0)
-    return;
-
-  if (!mydc)
-    mydc = gdk_fb_cursor_dc_reset ();
-
-  if (last_contents)
-    {
-      gdk_gc_set_clip_mask (cursor_gc, NULL);
-      /* Restore old picture */
-      gdk_fb_draw_drawable_3 (GDK_DRAWABLE_IMPL(_gdk_parent_root),
-			      cursor_gc,
-			      GDK_DRAWABLE_IMPL(last_contents),
-			      mydc,
-			      0, 0,
-			      last_location.x,
-			      last_location.y,
-			      last_contents_size.x,
-			      last_contents_size.y);
-      gdk_shadow_fb_update (last_location.x, last_location.y,
-			    last_location.x + last_contents_size.x,
-			    last_location.y + last_contents_size.y);
-    }
-}
-
-void
-gdk_fb_cursor_invalidate (void)
-{
-  if (last_contents)
-    {
-      gdk_pixmap_unref (last_contents);
-      last_contents = NULL;
-    }
-}
-
-void
-gdk_fb_cursor_unhide()
-{
-  GdkFBDrawingContext *mydc = gdk_fb_cursor_dc;
-  GdkCursorPrivateFB *last_private;
-  GdkDrawableFBData *pixmap_last;
-  
-  last_private = GDK_CURSOR_FB (last_cursor);
-  cursor_visibility_count++;
-  g_assert (cursor_visibility_count <= 1);
-  if (cursor_visibility_count < 1)
-    return;
-
-  if (!mydc)
-    mydc = gdk_fb_cursor_dc_reset ();
-
-  if (last_cursor)
-    {
-      pixmap_last = GDK_DRAWABLE_IMPL_FBDATA (last_private->cursor);
-      
-      if (!last_contents ||
-	  pixmap_last->width > GDK_DRAWABLE_IMPL_FBDATA (last_contents)->width ||
-	  pixmap_last->height > GDK_DRAWABLE_IMPL_FBDATA (last_contents)->height)
-	{
-	  if (last_contents)
-	    gdk_pixmap_unref (last_contents);
-
-	  last_contents = gdk_pixmap_new (_gdk_parent_root,
-					  pixmap_last->width,
-					  pixmap_last->height,
-					  GDK_DRAWABLE_IMPL_FBDATA (_gdk_parent_root)->depth);
-	}
-
-      gdk_gc_set_clip_mask (cursor_gc, NULL);
-      gdk_fb_draw_drawable_2 (GDK_DRAWABLE_IMPL (last_contents),
-			      cursor_gc,
-			      GDK_DRAWABLE_IMPL (_gdk_parent_root),
-			      last_location.x,
-			      last_location.y,
-			      0, 0,
-			      pixmap_last->width,
-			      pixmap_last->height,
-			      TRUE, FALSE);
-      last_contents_size.x = pixmap_last->width;
-      last_contents_size.y = pixmap_last->height;
-      
-      gdk_gc_set_clip_mask (cursor_gc, last_private->mask);
-      gdk_gc_set_clip_origin (cursor_gc,
-			      last_location.x,
-			      last_location.y);
-
-      gdk_fb_cursor_dc_reset ();
-      gdk_fb_draw_drawable_3 (GDK_DRAWABLE_IMPL (_gdk_parent_root),
-			      cursor_gc,
-			      GDK_DRAWABLE_IMPL (last_private->cursor),
-			      mydc,
-			      0, 0,
-			      last_location.x, last_location.y,
-			      pixmap_last->width,
-			      pixmap_last->height);
-      gdk_shadow_fb_update (last_location.x, last_location.y,
-			    last_location.x + pixmap_last->width,
-			    last_location.y + pixmap_last->height);
-    }
-  else
-    gdk_fb_cursor_invalidate ();
-}
-
-gboolean
-gdk_fb_cursor_region_need_hide (GdkRegion *region)
-{
-  GdkRectangle testme;
-
-  if (!last_cursor)
-    return FALSE;
-
-  testme.x = last_location.x;
-  testme.y = last_location.y;
-  testme.width = GDK_DRAWABLE_IMPL_FBDATA (GDK_CURSOR_FB (last_cursor)->cursor)->width;
-  testme.height = GDK_DRAWABLE_IMPL_FBDATA (GDK_CURSOR_FB (last_cursor)->cursor)->height;
-
-  return (gdk_region_rect_in (region, &testme) != GDK_OVERLAP_RECTANGLE_OUT);
-}
-
-gboolean
-gdk_fb_cursor_need_hide (GdkRectangle *rect)
-{
-  GdkRectangle testme;
-
-  if (!last_cursor)
-    return FALSE;
-
-  testme.x = last_location.x;
-  testme.y = last_location.y;
-  testme.width = GDK_DRAWABLE_IMPL_FBDATA (GDK_CURSOR_FB (last_cursor)->cursor)->width;
-  testme.height = GDK_DRAWABLE_IMPL_FBDATA (GDK_CURSOR_FB (last_cursor)->cursor)->height;
-
-  return gdk_rectangle_intersect (rect, &testme, &testme);
-}
-
-void
-gdk_fb_get_cursor_rect (GdkRectangle *rect)
-{
-  if (last_cursor)
-    {
-      rect->x = last_location.x;
-      rect->y = last_location.y;
-      rect->width = GDK_DRAWABLE_IMPL_FBDATA (GDK_CURSOR_FB (last_cursor)->cursor)->width;
-      rect->height = GDK_DRAWABLE_IMPL_FBDATA (GDK_CURSOR_FB (last_cursor)->cursor)->height;
-    }
-  else
-    {
-      rect->x = rect->y = -1;
-      rect->width = rect->height = 0;
-    }
-}
-
-void
-gdk_fb_cursor_move (gint x, gint y, GdkWindow *in_window)
-{
-  GdkCursor *the_cursor;
-
-  if (!cursor_gc)
-    {
-      GdkColor white, black;
-      cursor_gc = gdk_gc_new (_gdk_parent_root);
-      gdk_color_black (gdk_colormap_get_system (), &black);
-      gdk_color_white (gdk_colormap_get_system (), &white);
-      gdk_gc_set_foreground (cursor_gc, &black);
-      gdk_gc_set_background (cursor_gc, &white);
-    }
-
-  gdk_fb_cursor_hide ();
-
-  if (_gdk_fb_pointer_grab_window)
-    {
-      if (_gdk_fb_pointer_grab_cursor)
-	the_cursor = _gdk_fb_pointer_grab_cursor;
-      else
-	{
-	  GdkWindow *win = _gdk_fb_pointer_grab_window;
-	  while (!GDK_WINDOW_IMPL_FBDATA (win)->cursor && GDK_WINDOW_OBJECT (win)->parent)
-	    win = (GdkWindow *)GDK_WINDOW_OBJECT (win)->parent;
-	  the_cursor = GDK_WINDOW_IMPL_FBDATA (win)->cursor;
-	}
-    }
-  else
-    {
-      while (!GDK_WINDOW_IMPL_FBDATA (in_window)->cursor && GDK_WINDOW_P (in_window)->parent)
-	in_window = (GdkWindow *)GDK_WINDOW_P (in_window)->parent;
-      the_cursor = GDK_WINDOW_IMPL_FBDATA (in_window)->cursor;
-    }
-
-  last_location.x = x - GDK_CURSOR_FB (the_cursor)->hot_x;
-  last_location.y = y - GDK_CURSOR_FB (the_cursor)->hot_y;
-
-  if (the_cursor)
-    gdk_cursor_ref (the_cursor);
-  if (last_cursor)
-    gdk_cursor_unref (last_cursor);
-  last_cursor = the_cursor;
-
-  gdk_fb_cursor_unhide ();
-}
-
-void
-gdk_fb_cursor_reset(void)
-{
-  GdkWindow *win = gdk_window_at_pointer (NULL, NULL);
-  gint x, y;
+void gdk_fb_cursor_hide (void)
+{
+}
+
+void gdk_fb_cursor_invalidate (void)
+{
+}
+
+void gdk_fb_cursor_unhide()
+{
+}
+
+gboolean gdk_fb_cursor_region_need_hide (GdkRegion *region)
+{
+	return FALSE;
+}
 
-  gdk_fb_mouse_get_info (&x, &y, NULL);
-  gdk_fb_cursor_move (x, y, win);
+gboolean gdk_fb_cursor_need_hide (GdkRectangle *rect)
+{
+	return FALSE;
+}
+
+void gdk_fb_get_cursor_rect (GdkRectangle *rect)
+{
+}
+
+void gdk_fb_cursor_move (gint x, gint y, GdkWindow *in_window)
+{
+}
+
+void gdk_fb_cursor_reset(void)
+{
 }
 
-GdkDisplay *
-gdk_cursor_get_display (GdkCursor *cursor)
+GdkDisplay * gdk_cursor_get_display (GdkCursor *cursor)
 {
-  return gdk_display_get_default ();
+  return gdk_display_get_default();
 }
diff -Naur gtk+-2.4.14/gdk/linux-fb/gdkdrawable-fb2.c gtk+-2.4.14-xynth/gdk/linux-fb/gdkdrawable-fb2.c
--- gtk+-2.4.14/gdk/linux-fb/gdkdrawable-fb2.c	2004-03-06 05:37:04.000000000 +0200
+++ gtk+-2.4.14-xynth/gdk/linux-fb/gdkdrawable-fb2.c	2006-12-12 12:48:04.000000000 +0200
@@ -1,3 +1,9 @@
+/*
+ * Gtk-Xynth port is based on linux-fb port
+ * Xynth Team
+ * http://www.xynth.org
+ */
+
 #include <config.h>
 #include "gdkprivate-fb.h"
 #include "mi.h"
@@ -1353,7 +1359,8 @@
 	  maxx += extra_width;
 	  maxy += extra_width;
 	}
-      gdk_shadow_fb_update (minx, miny, maxx, maxy);
+
+	gdk_shadow_fb_update(drawable, minx, miny, maxx, maxy);
     }
 }
 
@@ -1392,7 +1399,8 @@
 	  maxx += extra_width;
 	  maxy += extra_width;
 	}
-      gdk_shadow_fb_update (minx, miny, maxx, maxy);
+
+	gdk_shadow_fb_update(drawable, minx, miny, maxx, maxy);
     }
 }
 
@@ -1434,8 +1442,8 @@
 	  maxx += extra_width;
 	  maxy += extra_width;
 	}
-      gdk_shadow_fb_update (minx + private->abs_x, miny + private->abs_y,
-			    maxx + private->abs_x, maxy + private->abs_y);
+
+	gdk_shadow_fb_update(drawable, minx + private->abs_x, miny + private->abs_y, maxx + private->abs_x, maxy + private->abs_y);
     }
 }
 
@@ -1477,9 +1485,10 @@
   _gdk_fb_draw_glyphs (drawable, gc, font, x, y, glyphs, &bbox);
   
   private = GDK_DRAWABLE_FBDATA (drawable);
-  if (GDK_IS_WINDOW (private->wrapper))
-    gdk_shadow_fb_update (bbox.x + private->abs_x, bbox.y + private->abs_y,
-			  bbox.x + private->abs_x + bbox.width, bbox.y + private->abs_y + bbox.height);
+
+	if (GDK_IS_WINDOW(private->wrapper)) {
+		gdk_shadow_fb_update(drawable, bbox.x + private->abs_x, bbox.y + private->abs_y, bbox.x + private->abs_x + bbox.width, bbox.y + private->abs_y + bbox.height);
+	}
 }
 
 static void
@@ -1498,9 +1507,10 @@
   gdk_fb_draw_drawable (drawable, gc, src, xsrc, ysrc, xdest, ydest, width, height);
   
   private = GDK_DRAWABLE_FBDATA (drawable);
-  if (GDK_IS_WINDOW (private->wrapper))
-    gdk_shadow_fb_update (xdest + private->abs_x, ydest + private->abs_y,
-			  xdest + private->abs_x + width, ydest + private->abs_y + height);
+
+	if (GDK_IS_WINDOW(private->wrapper)) {
+		gdk_shadow_fb_update(drawable, xdest + private->abs_x, ydest + private->abs_y, xdest + private->abs_x + width, ydest + private->abs_y + height);
+	}
 }
 
 static void
@@ -1519,9 +1529,10 @@
   gdk_fb_draw_image (drawable, gc, image, xsrc, ysrc, xdest, ydest, width, height);
   
   private = GDK_DRAWABLE_FBDATA (drawable);
-  if (GDK_IS_WINDOW (private->wrapper))
-    gdk_shadow_fb_update (xdest + private->abs_x, ydest + private->abs_y,
-			  xdest + private->abs_x + width, ydest + private->abs_y + height);
+
+	if (GDK_IS_WINDOW(private->wrapper)) {
+		gdk_shadow_fb_update(drawable, xdest + private->abs_x, ydest + private->abs_y, xdest + private->abs_x + width, ydest + private->abs_y + height);
+	}
 }
 
 static void
@@ -1551,8 +1562,7 @@
 	  maxy = MAX(maxy, points[i].y);
 	}
       
-      gdk_shadow_fb_update (minx + private->abs_x, miny + private->abs_y,
-			    maxx + private->abs_x, maxy + private->abs_y);
+	gdk_shadow_fb_update(drawable, minx + private->abs_x, miny + private->abs_y, maxx + private->abs_x, maxy + private->abs_y);
     }
 }
 
@@ -1597,8 +1607,7 @@
       maxx += extra_width;
       maxy += extra_width;
       
-      gdk_shadow_fb_update (minx + private->abs_x, miny + private->abs_y,
-			    maxx + private->abs_x, maxy + private->abs_y);
+	gdk_shadow_fb_update(drawable, minx + private->abs_x, miny + private->abs_y, maxx + private->abs_x, maxy + private->abs_y);
     }
 }
 
@@ -1637,8 +1646,7 @@
       maxx += extra_width;
       maxy += extra_width;
       
-      gdk_shadow_fb_update (minx + private->abs_x, miny + private->abs_y,
-			    maxx + private->abs_x, maxy + private->abs_y);
+	gdk_shadow_fb_update(drawable, minx + private->abs_x, miny + private->abs_y, maxx + private->abs_x, maxy + private->abs_y);
     }
 }
 
diff -Naur gtk+-2.4.14/gdk/linux-fb/gdkevents-fb.c gtk+-2.4.14-xynth/gdk/linux-fb/gdkevents-fb.c
--- gtk+-2.4.14/gdk/linux-fb/gdkevents-fb.c	2004-03-06 05:37:04.000000000 +0200
+++ gtk+-2.4.14-xynth/gdk/linux-fb/gdkevents-fb.c	2006-12-12 12:48:04.000000000 +0200
@@ -23,6 +23,12 @@
  * files for a list of changes.  These files are distributed with
  * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
  */
+ 
+/*
+ * Gtk-Xynth port is based on linux-fb port
+ * Xynth Team
+ * http://www.xynth.org
+ */
 
 #include <config.h>
 #include "gdk.h"
@@ -124,13 +130,10 @@
 {  
 }
 
-static gboolean
-fb_events_prepare (GSource    *source,
-		   gint       *timeout)
+static gboolean fb_events_prepare (GSource *source, gint *timeout)
 {
-  *timeout = -1;
-
-  return fb_events_check (source);
+	*timeout = 100;
+	return fb_events_check (source);
 }
 
 static gboolean
@@ -147,34 +150,40 @@
   return retval;
 }
 
-static gboolean
-fb_events_dispatch (GSource  *source,
-		    GSourceFunc callback,
-		    gpointer  user_data)
+static gboolean fb_events_dispatch (GSource *source, GSourceFunc callback, gpointer user_data)
 {
-  GdkEvent *event;
+	GdkEvent *event;
 
-  GDK_THREADS_ENTER ();
+	GDK_THREADS_ENTER();
 
-  while ((event = _gdk_event_unqueue (gdk_display_get_default ())))
-    {
-      if (event->type == GDK_EXPOSE &&
-	  event->expose.window == _gdk_parent_root)
-	gdk_window_clear_area (event->expose.window,
-			       event->expose.area.x,
-			       event->expose.area.y,
-			       event->expose.area.width,
-			       event->expose.area.height);
-
-      else if (_gdk_event_func)
-	(*_gdk_event_func) (event, _gdk_event_data);
-
-      gdk_event_free (event);
-    }
-
-  GDK_THREADS_LEAVE ();
+	while ((event = _gdk_event_unqueue(gdk_display_get_default()))) {
+		if (event->type == GDK_CONFIGURE) {
+			if ((event->configure.x != GDK_DRAWABLE_IMPL_FBDATA(event->configure.window)->xynth_window->surface->buf->x) ||
+			    (event->configure.y != GDK_DRAWABLE_IMPL_FBDATA(event->configure.window)->xynth_window->surface->buf->y) ||
+			    (event->configure.width != GDK_DRAWABLE_IMPL_FBDATA(event->configure.window)->xynth_window->surface->buf->w) ||
+			    (event->configure.height != GDK_DRAWABLE_IMPL_FBDATA(event->configure.window)->xynth_window->surface->buf->h)) {
+				s_window_set_coor(GDK_DRAWABLE_IMPL_FBDATA(event->configure.window)->xynth_window,
+				                  WINDOW_NOFORM,
+				                  event->configure.x,
+				                  event->configure.y,
+				                  event->configure.width,
+				                  event->configure.height);
+			}
+                }
+		if (event->type == GDK_EXPOSE && event->expose.window == _gdk_parent_root) {
+			gdk_window_clear_area (event->expose.window,
+			                       event->expose.area.x,
+			                       event->expose.area.y,
+			                       event->expose.area.width,
+			                       event->expose.area.height);
+		} else if (_gdk_event_func) {
+			(*_gdk_event_func) (event, _gdk_event_data);
+		}
+		gdk_event_free(event);
+	}
+	GDK_THREADS_LEAVE();
 
-  return TRUE;
+	return TRUE;
 }
 
 /*
diff -Naur gtk+-2.4.14/gdk/linux-fb/gdkgeometry-fb.c gtk+-2.4.14-xynth/gdk/linux-fb/gdkgeometry-fb.c
--- gtk+-2.4.14/gdk/linux-fb/gdkgeometry-fb.c	2004-03-06 05:37:04.000000000 +0200
+++ gtk+-2.4.14-xynth/gdk/linux-fb/gdkgeometry-fb.c	2006-12-12 12:48:04.000000000 +0200
@@ -49,9 +49,7 @@
 			      dest_rect.x, dest_rect.y,
 			      dest_rect.width, dest_rect.height,
 			      FALSE, FALSE);
-      gdk_shadow_fb_update (dest_rect.x - dx, dest_rect.y - dy,
-			    dest_rect.x - dx + dest_rect.width,
-			    dest_rect.y - dy + dest_rect.height);
+	gdk_shadow_fb_update(GDK_DRAWABLE_IMPL(window), dest_rect.x - dx, dest_rect.y - dy, dest_rect.x - dx + dest_rect.width, dest_rect.y - dy + dest_rect.height);
     }
   
   gdk_window_invalidate_region (window, invalidate_region, TRUE);
diff -Naur gtk+-2.4.14/gdk/linux-fb/gdkglobals-fb.c gtk+-2.4.14-xynth/gdk/linux-fb/gdkglobals-fb.c
--- gtk+-2.4.14/gdk/linux-fb/gdkglobals-fb.c	2004-03-06 06:00:07.000000000 +0200
+++ gtk+-2.4.14-xynth/gdk/linux-fb/gdkglobals-fb.c	2006-12-12 12:48:04.000000000 +0200
@@ -45,4 +45,3 @@
 GdkGC *_gdk_fb_screen_gc = NULL;
 GdkAtom _gdk_selection_property;
 GdkFBAngle _gdk_fb_screen_angle = GDK_FB_0_DEGREES;
-volatile gboolean _gdk_fb_is_active_vt = FALSE;
diff -Naur gtk+-2.4.14/gdk/linux-fb/gdkkeyboard-fb.c gtk+-2.4.14-xynth/gdk/linux-fb/gdkkeyboard-fb.c
--- gtk+-2.4.14/gdk/linux-fb/gdkkeyboard-fb.c	2004-03-06 05:37:04.000000000 +0200
+++ gtk+-2.4.14-xynth/gdk/linux-fb/gdkkeyboard-fb.c	2006-12-12 12:48:04.000000000 +0200
@@ -16,6 +16,12 @@
  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA.
  */
+ 
+/*
+ * Gtk-Xynth port is based on linux-fb port
+ * Xynth Team
+ * http://www.xynth.org
+ */
 
 #include <config.h>
 #include <gdk/gdk.h>
@@ -36,24 +42,13 @@
 typedef struct _GdkFBKeyboardDevice GdkFBKeyboardDevice;
 
 struct _GdkFBKeyboard {
-  gint fd;
-  GIOChannel *io;
-  gint io_tag;
-
   guint modifier_state;
   guint caps_lock : 1;
-
-  gint group;
-  gint level;
-  
   GdkFBKeyboardDevice *dev;
 };
 
 struct _GdkFBKeyboardDevice {
   char *name;
-  gboolean (*open)(GdkFBKeyboard *kb);
-  void (*close)(GdkFBKeyboard *kb);
-
   guint    (*lookup_key)               (GdkFBKeyboard       *kb,
 					const GdkKeymapKey  *key);
   gboolean (*translate_keyboard_state) (GdkFBKeyboard       *kb,
@@ -73,15 +68,11 @@
 					GdkKeymapKey       **keys,
 					guint              **keyvals,
 					gint                *n_entries);
-
-  gpointer driver_data;
 };
 
 static GdkFBKeyboard *gdk_fb_keyboard = NULL;
 static GdkKeymap *default_keymap = NULL;
 
-static gboolean xlate_open            (GdkFBKeyboard       *kb);
-static void     xlate_close           (GdkFBKeyboard       *kb);
 static guint    xlate_lookup          (GdkFBKeyboard       *kb,
 				       const GdkKeymapKey  *key);
 static gboolean xlate_translate       (GdkFBKeyboard       *kb,
@@ -102,8 +93,6 @@
 				       guint              **keyvals,
 				       gint                *n_entries);
 
-static gboolean raw_open            (GdkFBKeyboard       *kb);
-static void     raw_close           (GdkFBKeyboard       *kb);
 static guint    raw_lookup          (GdkFBKeyboard       *kb,
 				     const GdkKeymapKey  *key);
 static gboolean raw_translate       (GdkFBKeyboard       *kb,
@@ -129,8 +118,6 @@
 {
   {
     "xlate",
-    xlate_open,
-    xlate_close,
     xlate_lookup,
     xlate_translate,
     xlate_get_for_keyval,
@@ -138,8 +125,6 @@
   },
   {
     "raw",
-    raw_open,
-    raw_close,
     raw_lookup,
     raw_translate,
     raw_get_for_keyval,
@@ -165,7 +150,6 @@
 PangoDirection
 gdk_keymap_get_direction (GdkKeymap *keymap)
 {
-  /* FIXME: Only supports LTR keymaps at the moment */
   return PANGO_DIRECTION_LTR;
 }
 
@@ -184,7 +168,6 @@
 
   gdk_fb_keyboard = g_new0 (GdkFBKeyboard, 1);
   keyb = gdk_fb_keyboard;
-  keyb->fd = -1;
   
   keyb_type = getenv ("GDK_KEYBOARD_TYPE");
   
@@ -205,38 +188,10 @@
 
   keyb->dev = &keyb_devs[i];
 
-  if (open_dev)
-    return gdk_fb_keyboard_open ();
-  else
     return TRUE;
 }
 
 gboolean
-gdk_fb_keyboard_open (void)
-{
-  GdkFBKeyboard *keyb;
-  GdkFBKeyboardDevice *device;
-
-  keyb = gdk_fb_keyboard;
-  device = keyb->dev;
-
-  if (!device->open(keyb))
-    {
-      g_warning ("Keyboard driver open failed");
-      return FALSE;
-    }
-
-  return TRUE;
-}
-
-void 
-gdk_fb_keyboard_close (void)
-{
-  gdk_fb_keyboard->dev->close(gdk_fb_keyboard);
-}
-
-
-gboolean
 gdk_keymap_get_entries_for_keyval (GdkKeymap     *keymap,
                                    guint          keyval,
                                    GdkKeymapKey **keys,
@@ -306,59 +261,25 @@
 							 consumed_modifiers);
 }
 
-static void
-gdk_fb_handle_key (guint hw_keycode,
-		   guint keyval,
-		   guint modifier_state,
-		   guint8 group,
-		   gchar *string,
-		   gint string_length,
-		   gboolean key_up)
-{
-  GdkWindow *win;
-  GdkEvent *event;
-
-  /* handle some magic keys */
-  if (key_up &&
-      (modifier_state & GDK_CONTROL_MASK) &&
-      (modifier_state & GDK_MOD1_MASK))
-    {
-      if (keyval == GDK_BackSpace)
-	{
-	  ioctl (gdk_display->tty_fd, KDSKBMODE, K_XLATE);
-	  exit (1);
-	}
-	  
-      if (keyval == GDK_Return)
-	gdk_fb_redraw_all ();
-    }
+void gdk_fb_handle_key (guint hw_keycode, guint keyval, guint modifier_state, guint8 group, gchar *string, gint string_length, gboolean key_up)
+{
+	GdkWindow *win;
+	GdkEvent *event;
 
-  win = gdk_fb_keyboard_event_window (gdk_fb_window_find_focus (),
-				      key_up ? GDK_KEY_RELEASE : GDK_KEY_PRESS);
-  if (win)
-    {
-      event = gdk_event_make (win,
-			      key_up ? GDK_KEY_RELEASE : GDK_KEY_PRESS,
-			      TRUE);
-    
-      event->key.state = modifier_state;
-      event->key.keyval = keyval;
-      event->key.string = string;
-      event->key.length = string_length;
-      event->key.hardware_keycode = hw_keycode;
-      event->key.group = group;
-    }
-  else
-    g_free (string);
+	win = gdk_fb_keyboard_event_window (gdk_fb_window_find_focus (), key_up ? GDK_KEY_RELEASE : GDK_KEY_PRESS);
+	if (win) {
+		event = gdk_event_make (win, key_up ? GDK_KEY_RELEASE : GDK_KEY_PRESS, TRUE);
+		event->key.state = modifier_state;
+		event->key.keyval = keyval;
+		event->key.string = string;
+		event->key.length = string_length;
+		event->key.hardware_keycode = hw_keycode;
+		event->key.group = group;
+	} else {
+		g_free (string);
+	}
 }
 
-/******************************************************
- ********* Device specific keyboard code **************
- ******************************************************/
-
-
-/* XLATE keyboard driver */
-
 struct {
   char *str;
   guint code;
@@ -377,7 +298,7 @@
   {"\x32\x31\x7e", GDK_F10},
   {"\x32\x33\x7e", GDK_F11},
   {"\x32\x34\x7e", GDK_F12},
-  
+
   {"\x32\x35\x7e", GDK_F1, GDK_SHIFT_MASK},
   {"\x32\x36\x7e", GDK_F2, GDK_SHIFT_MASK},
   {"\x32\x38\x7e", GDK_F3, GDK_SHIFT_MASK},
@@ -680,206 +601,6 @@
   {0, 0},
 };
 
-static gboolean
-iscode (char *code, char *str, int str_max)
-{
-  int i;
-
-  for (i = 0; code[i] && (i < str_max); i++)
-    {
-      if (code[i] != str[i])
-	return FALSE;
-    }
-  return (code[i] == 0);
-}
-
-static gboolean
-xlate_io (GIOChannel *gioc,
-	  GIOCondition cond,
-	  gpointer data)
-{
-  GdkFBKeyboard *keyb = (GdkFBKeyboard *)data;
-  guchar buf[128];
-  guint keycode;
-  guint modifier;
-  gboolean handled;
-  int i, n, j;
-  int left;
-  
-  n = read (keyb->fd, buf, sizeof(buf));
-  if (n <= 0)
-    g_error ("Nothing from keyboard!");
-
-  for (i = 0; i < n; )
-    {
-      handled = FALSE;
-      modifier = 0;
-      if ((buf[i] == 27) && (i+1 != n)) /* Escape */
-	{
-	  /* Esc is not the last char in buffer, interpret as code sequence */
-	  if (buf[i+1] == '[')
-	    {
-	      i += 2;
-	      left = n-i;
-	      if (left <= 0)
-		return TRUE;
-
-	      for (j=0;j<G_N_ELEMENTS (xlate_codes);j++)
-		{
-		  if (iscode (xlate_codes[j].str, &buf[i], left))
-		    {
-		      /* Ctrl-Alt Return can't be pressed in the XLATE driver,
-		       * use Shift F1 instead */
-		      if ((xlate_codes[j].code == GDK_F1) &&
-			  (xlate_codes[j].modifier & GDK_SHIFT_MASK))
-			gdk_fb_redraw_all ();
-
-		      if ((xlate_codes[j].code == GDK_F2) &&
-			  (xlate_codes[j].modifier & GDK_SHIFT_MASK))
-			{
-			  static gint deg = 0;
-			  deg = (deg + 1) % 4;
-			    
-			  gdk_fb_set_rotation (deg);
-			}
-
-		      if ((xlate_codes[j].code == GDK_F8) &&
-			  (xlate_codes[j].modifier & GDK_SHIFT_MASK))
-			exit (1);
-
-		      
-		      gdk_fb_handle_key (xlate_codes[j].code,
-					 xlate_codes[j].code,
-					 xlate_codes[j].modifier,
-					 0,
-					 NULL,
-					 0,
-					 FALSE);
-		      gdk_fb_handle_key (xlate_codes[j].code,
-					 xlate_codes[j].code,
-					 xlate_codes[j].modifier,
-					 0,
-					 NULL,
-					 0,
-					 TRUE);
-		      i += strlen (xlate_codes[j].str);
-		      handled = TRUE;
-		      break;
-		    }
-		}
-	    }
-	  else
-	    {
-	      /* Alt-key */
-	      modifier |= GDK_MOD1_MASK;
-	      i++;
-	    }
-	}
-      if (!handled)
-	{
-	  char dummy[2];
-	  gint len;
-	  
-	  keycode = xlate_chars[buf[i]].code;
-	  if (keycode == 0)
-	    keycode = buf[i];
-	  modifier |= xlate_chars[buf[i]].modifier;
-	  
-	  dummy[0] = keycode;
-	  dummy[1] = 0;
-
-	  len = ((keycode < 255) && isprint (keycode)) ? 1 : 0;
-	  gdk_fb_handle_key (keycode,
-			     keycode,
-			     modifier,
-			     0,
-			     (len)?g_strdup(dummy) : NULL,
-			     len,
-			     FALSE);
-	  gdk_fb_handle_key (keycode,
-			     keycode,
-			     modifier,
-			     0,
-			     (len)?g_strdup(dummy) : NULL,
-			     len,
-			     TRUE);
-	  i++;
-	}
-    }
-  return TRUE;
-}
-
-static gboolean
-write_string (gint         fd,
-	      const gchar *str)
-{
-  gsize to_write = strlen (str);
-
-  while (to_write > 0)
-    {
-      gssize count = write (fd, str, to_write);
-      if (count < 0)
-	{
-	  if (errno != EINTR)
-	    return FALSE;
-	}
-      else
-	{
-	  to_write -= count;
-	  str += count;
-	}
-    }
-
-  return TRUE;
-}
-
-static gboolean
-xlate_open (GdkFBKeyboard *kb)
-{
-  const char cursoroff_str[] = "\033[?1;0;0c";
-  struct termios ts;
-  
-  tcgetattr (gdk_display->tty_fd, &ts);
-  ts.c_cc[VTIME] = 0;
-  ts.c_cc[VMIN] = 1;
-  ts.c_lflag &= ~(ICANON|ECHO|ISIG);
-  ts.c_iflag = 0;
-  tcsetattr (gdk_display->tty_fd, TCSAFLUSH, &ts);
-
-  tcsetpgrp (gdk_display->tty_fd, getpgrp());
-
-  write_string (gdk_display->tty_fd, cursoroff_str);
-  
-  ioctl (gdk_display->tty_fd, KDSKBMODE, K_XLATE);
-
-  kb->fd = gdk_display->tty_fd;
-  kb->io = g_io_channel_unix_new (kb->fd);
-  kb->io_tag = g_io_add_watch (kb->io,
-			       G_IO_IN | G_IO_ERR | G_IO_HUP | G_IO_NVAL,
-			       xlate_io,
-			       kb);
-  
-  return TRUE;
-}
-
-static void
-xlate_close (GdkFBKeyboard *kb)
-{
-  struct termios ts;
-  const char cursoron_str[] = "\033c\033[3g\033]R";
-
-  write_string (gdk_display->tty_fd, cursoron_str);
-
-  tcgetattr (gdk_display->tty_fd, &ts);
-  ts.c_lflag |= (ICANON|ECHO|ISIG);
-  tcsetattr (gdk_display->tty_fd, TCSAFLUSH, &ts);
-  
-  g_source_remove (kb->io_tag);
-  g_io_channel_unref (kb->io);
-  kb->fd = -1;
-  /* don't close kb->fd, it is the tty from gdk_display */
-}
-
 static guint
 xlate_lookup (GdkFBKeyboard       *kb,
 	      const GdkKeymapKey  *key)
@@ -1244,179 +965,6 @@
   {0, 0, 0},
 };
 
-static gboolean
-raw_io (GIOChannel *gioc,
-	GIOCondition cond,
-	gpointer data)
-{
-  GdkFBKeyboard *k = data;
-  guchar buf[128];
-  int i, n;
-
-  n = read (k->fd, buf, sizeof(buf));
-  if (n <= 0)
-    g_error("Nothing from keyboard!");
-
-  for (i = 0; i < n; i++)
-    {
-      guchar keycode;
-      gboolean key_up;
-      char dummy[2];
-      int len;
-      int mod;
-      guint keyval;
-
-      keycode = buf[i] & 0x7F;
-      key_up = buf[i] & 0x80;
-
-      if (keycode > G_N_ELEMENTS (trans_table))
-	{
-	  g_warning ("Unknown keycode");
-	  continue;
-	}
-
-      if ( (keycode == 0x1D) /* left Ctrl */
-	   || (keycode == 0x9D) /* right Ctrl */
-	   || (keycode == 0x38) /* left Alt */
-	   || (keycode == 0xB8) /* right Alt */
-	   || (keycode == 0x2A) /* left Shift */
-	   || (keycode == 0x36) /* right Shift */)
-	{
-	  switch (keycode)
-	    {
-	    case 0x1D: /* Left Ctrl */
-	    case 0x9D: /* Right Ctrl */
-	      if (key_up)
-		k->modifier_state &= ~GDK_CONTROL_MASK;
-	      else
-		k->modifier_state |= GDK_CONTROL_MASK;
-	      break;
-	    case 0x38: /* Left Alt */
-	    case 0xB8: /* Right Alt */
-	      if (key_up)
-		k->modifier_state &= ~GDK_MOD1_MASK;
-	      else
-		k->modifier_state |= GDK_MOD1_MASK;
-	      break;
-	    case 0x2A: /* Left Shift */
-	    case 0x36: /* Right Shift */
-	      if (key_up)
-		k->modifier_state &= ~GDK_SHIFT_MASK;
-	      else
-		k->modifier_state |= GDK_SHIFT_MASK;
-	      break;
-	    }
-	  continue; /* Don't generate events for modifiers */
-	}
-
-      if (keycode == 0x3A /* Caps lock */)
-	{
-	  if (!key_up)
-	    k->caps_lock = !k->caps_lock;
-	  
-	  ioctl (k->fd, KDSETLED, k->caps_lock ? LED_CAP : 0);
-	  continue;
-	}
-
-      if (trans_table[keycode][0] >= GDK_F1 &&
-	  trans_table[keycode][0] <= GDK_F35 &&
-	  (k->modifier_state & GDK_MOD1_MASK))
-	{
-	  if (key_up) /* Only switch on release */
-	    {
-	      gint vtnum = trans_table[keycode][0] - GDK_F1 + 1;
-
-	      /* Do the whole funky VT switch thing */
-	      ioctl (gdk_display->console_fd, VT_ACTIVATE, vtnum);
-	    }
-
-	  continue;
-	}
-
-      keyval = 0;
-      mod = 0;
-      if (k->modifier_state & GDK_CONTROL_MASK)
-	mod = 2;
-      else if (k->modifier_state & GDK_SHIFT_MASK)
-	mod = 1;
-      do {
-	keyval = trans_table[keycode][mod--];
-      } while (!keyval && (mod >= 0));
-
-      if (k->caps_lock && (keyval >= 'a') && (keyval <= 'z'))
-	keyval = toupper (keyval);
-
-      if (!keyval)
-	continue;
-
-      len = isprint (keyval) ? 1 : 0;
-      dummy[0] = keyval;
-      dummy[1] = 0;
-
-      gdk_fb_handle_key (keycode,
-			 keyval,
-			 k->modifier_state,
-			 0,
-			 (len)?g_strdup(dummy):NULL,
-			 len,
-			 key_up);
-    }
-
-  return TRUE;
-}
-
-static gboolean
-raw_open (GdkFBKeyboard *kb)
-{
-  const char cursoroff_str[] = "\033[?1;0;0c";
-  struct termios ts;
-  
-  tcgetattr (gdk_display->tty_fd, &ts);
-  ts.c_cc[VTIME] = 0;
-  ts.c_cc[VMIN] = 1;
-  ts.c_lflag &= ~(ICANON|ECHO|ISIG);
-  ts.c_iflag = 0;
-  tcsetattr (gdk_display->tty_fd, TCSAFLUSH, &ts);
-
-  tcsetpgrp (gdk_display->tty_fd, getpgrp());
-
-  write_string (gdk_display->tty_fd, cursoroff_str);
-  
-  if (ioctl (gdk_display->tty_fd, KDSKBMODE, K_MEDIUMRAW) < 0)
-    {
-      g_warning ("setting tty to K_MEDIUMRAW failed (are you root?)");
-      return FALSE;
-    }
-
-  kb->fd = gdk_display->tty_fd;
-  kb->io = g_io_channel_unix_new (kb->fd);
-  kb->io_tag = g_io_add_watch (kb->io,
-			       G_IO_IN | G_IO_ERR | G_IO_HUP | G_IO_NVAL,
-			       raw_io,
-			       kb);
-  
-  return TRUE;
-}
-
-static void
-raw_close (GdkFBKeyboard *kb)
-{
-  struct termios ts;
-  const char cursoron_str[] = "\033c";
-
-  write_string (gdk_display->tty_fd, cursoron_str);
-
-  tcgetattr (gdk_display->tty_fd, &ts);
-  ts.c_lflag |= (ICANON|ECHO|ISIG);
-  tcsetattr (gdk_display->tty_fd, TCSAFLUSH, &ts);
-  
-  ioctl (gdk_display->tty_fd, KDSKBMODE, K_XLATE);
-
-  g_source_remove (kb->io_tag);
-  g_io_channel_unref (kb->io);
-  /* don't close kb->fd, it is the tty from gdk_display */
-}
-
 static guint
 raw_lookup (GdkFBKeyboard       *kb,
 	    const GdkKeymapKey  *key)
@@ -1530,7 +1078,7 @@
 
   if (hardware_keycode <= 0 ||
       hardware_keycode >= 256)
-    { 
+    {
       if (keys)
         *keys = NULL;
       if (keyvals)
@@ -1571,7 +1119,7 @@
 
   if ((key_array && key_array->len > 0) ||
       (keyval_array && keyval_array->len > 0))
-    { 
+    {
       if (keys)
         *keys = (GdkKeymapKey*) key_array->data;
 
@@ -1584,7 +1132,7 @@
         *n_entries = keyval_array->len;
     }
   else
-    { 
+    {
       if (keys)
         *keys = NULL;
 
diff -Naur gtk+-2.4.14/gdk/linux-fb/gdkmain-fb.c gtk+-2.4.14-xynth/gdk/linux-fb/gdkmain-fb.c
--- gtk+-2.4.14/gdk/linux-fb/gdkmain-fb.c	2004-03-06 05:37:04.000000000 +0200
+++ gtk+-2.4.14-xynth/gdk/linux-fb/gdkmain-fb.c	2006-12-12 12:48:04.000000000 +0200
@@ -23,6 +23,12 @@
  * files for a list of changes.  These files are distributed with
  * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
  */
+ 
+/*
+ * Gtk-Xynth port is based on linux-fb port
+ * Xynth Team
+ * http://www.xynth.org
+ */
 
 #include <config.h>
 #include <unistd.h>
@@ -69,795 +75,60 @@
   { NULL }
 };
 
-static const GScannerConfig     fb_modes_scanner_config =
-{
-  (
-   " \t\n"
-   )                    /* cset_skip_characters */,
-  (
-   G_CSET_a_2_z
-   G_CSET_A_2_Z
-   )                    /* cset_identifier_first */,
-  (
-   G_CSET_a_2_z
-   "_-0123456789"
-   G_CSET_A_2_Z
-   )                    /* cset_identifier_nth */,
-  ( "#\n" )             /* cpair_comment_single */,
-  
-  FALSE                  /* case_sensitive */,
-  
-  FALSE                 /* skip_comment_multi */,
-  TRUE                  /* skip_comment_single */,
-  FALSE                 /* scan_comment_multi */,
-  TRUE                  /* scan_identifier */,
-  TRUE                  /* scan_identifier_1char */,
-  FALSE                 /* scan_identifier_NULL */,
-  TRUE                  /* scan_symbols */,
-  FALSE                 /* scan_binary */,
-  FALSE                 /* scan_octal */,
-  FALSE                  /* scan_float */,
-  FALSE                  /* scan_hex */,
-  FALSE                 /* scan_hex_dollar */,
-  FALSE                 /* scan_string_sq */,
-  TRUE                  /* scan_string_dq */,
-  TRUE                  /* numbers_2_int */,
-  FALSE                 /* int_2_float */,
-  FALSE                 /* identifier_2_string */,
-  TRUE                  /* char_2_token */,
-  FALSE                 /* symbol_2_token */,
-  FALSE                 /* scope_0_fallback */,
-};
-
-enum {
-  FB_MODE,
-  FB_ENDMODE,
-  FB_GEOMETRY,
-  FB_TIMINGS,
-  FB_LACED,
-  FB_HSYNC,
-  FB_VSYNC,
-  FB_CSYNC,
-  FB_EXTSYNC,
-  FB_DOUBLE,
-  FB_ACCEL
-};
-
-char *fb_modes_keywords[] =
-{
-  "mode",
-  "endmode",
-  "geometry",
-  "timings",
-  "laced",
-  "hsync",
-  "vsync",
-  "csync",
-  "extsync",
-  "double",
-  "accel"
-};
-
-static int
-fb_modes_parse_mode (GScanner *scanner,
-		     struct fb_var_screeninfo *modeinfo,
-		     char *specified_modename)
-{
-  guint token;
-  int keyword;
-  int i;
-  char *modename;
-  int geometry[5];
-  int timings[7];
-  int vsync=0, hsync=0, csync=0, extsync=0, doublescan=0, laced=0, accel=1;
-  int found_geometry = 0;
-  int found_timings = 0;
-    
-  token = g_scanner_get_next_token (scanner);
-  if (token != G_TOKEN_SYMBOL)
-    return -1;
-  
-  keyword = GPOINTER_TO_INT (scanner->value.v_symbol);
-  if (keyword != FB_MODE)
-    return -1;
-
-  token = g_scanner_get_next_token (scanner);
-  if (token != G_TOKEN_STRING)
-    return -1;
-
-  modename = g_strdup (scanner->value.v_string);
-  
-  token = g_scanner_get_next_token (scanner);
-  if (token != G_TOKEN_SYMBOL)
-    {
-      g_free (modename);
-      return -1; /* Not a valid keyword */
-    }
-  keyword = GPOINTER_TO_INT (scanner->value.v_symbol);
-  while ( keyword != FB_ENDMODE )
-    {
-
-      switch (GPOINTER_TO_INT (scanner->value.v_symbol))
-	{
-	case FB_GEOMETRY:
-	  for (i = 0; i < 5;i++) {
-	    token = g_scanner_get_next_token (scanner);
-	    if (token != G_TOKEN_INT)
-	      {
-		g_free (modename);
-		return -1; /* need a integer */
-	      }
-	    geometry[i] = scanner->value.v_int;
-	  }
-	  found_geometry = TRUE;
-	  break;
-	case FB_TIMINGS:
-	  for (i = 0; i < 7; i++) {
-	    token = g_scanner_get_next_token (scanner);
-	    if (token != G_TOKEN_INT)
-	      {
-		g_free (modename);
-		return -1; /* need a integer */
-	      }
-	    timings[i] = scanner->value.v_int;
-	  }
-	  found_timings = TRUE;
-	  break;
-	case FB_LACED:
-	  token = g_scanner_get_next_token (scanner);
-	  if (token != G_TOKEN_IDENTIFIER)
-	      {
-		g_free (modename);
-		return -1;
-	      }
-	  if (g_ascii_strcasecmp (scanner->value.v_identifier, "true")==0)
-	    laced = 1;
-	  else if (g_ascii_strcasecmp (scanner->value.v_identifier, "false")==0)
-	    laced = 0;
-	  else
-	    {
-	      g_free (modename);
-	      return -1;
-	    }
-	  break;
-	case FB_EXTSYNC:
-	  token = g_scanner_get_next_token (scanner);
-	  if (token != G_TOKEN_IDENTIFIER)
-	      {
-		g_free (modename);
-		return -1;
-	      }
-	  if (g_ascii_strcasecmp (scanner->value.v_identifier, "true")==0)
-	    extsync = 1;
-	  else if (g_ascii_strcasecmp (scanner->value.v_identifier, "false")==0)
-	    extsync = 0;
-	  else
-	    {
-	      g_free (modename);
-	      return -1;
-	    }
-	  break;
-	case FB_DOUBLE:
-	  token = g_scanner_get_next_token (scanner);
-	  if (token != G_TOKEN_IDENTIFIER)
-	      {
-		g_free (modename);
-		return -1;
-	      }
-	  if (g_ascii_strcasecmp (scanner->value.v_identifier, "true")==0)
-	    doublescan = 1;
-	  else if (g_ascii_strcasecmp (scanner->value.v_identifier, "false")==0)
-	    doublescan = 0;
-	  else
-	    {
-	      g_free (modename);
-	      return -1;
-	    }
-	  break;
-	case FB_VSYNC:
-	  token = g_scanner_get_next_token (scanner);
-	  if (token != G_TOKEN_IDENTIFIER)
-	      {
-		g_free (modename);
-		return -1;
-	      }
-	  if (g_ascii_strcasecmp (scanner->value.v_identifier, "high")==0)
-	    vsync = 1;
-	  else if (g_ascii_strcasecmp (scanner->value.v_identifier, "low")==0)
-	    vsync = 0;
-	  else
-	    {
-	      g_free (modename);
-	      return -1;
-	    }
-	  break;
-	case FB_HSYNC:
-	  token = g_scanner_get_next_token (scanner);
-	  if (token != G_TOKEN_IDENTIFIER)
-	    {
-	      g_free (modename);
-	      return -1;
-	    }
-	  if (g_ascii_strcasecmp (scanner->value.v_identifier, "high")==0)
-	    hsync = 1;
-	  else if (g_ascii_strcasecmp (scanner->value.v_identifier, "low")==0)
-	    hsync = 0;
-	  else
-	    {
-	      g_free (modename);
-	      return -1;
-	    }
-	  break;
-	case FB_CSYNC:
-	  token = g_scanner_get_next_token (scanner);
-	  if (token != G_TOKEN_IDENTIFIER)
-	    {
-	      g_free (modename);
-	      return -1;
-	    }
-	  if (g_ascii_strcasecmp (scanner->value.v_identifier, "high")==0)
-	    csync = 1;
-	  else if (g_ascii_strcasecmp (scanner->value.v_identifier, "low")==0)
-	    csync = 0;
-	  else
-	    {
-	      g_free (modename);
-	      return -1;
-	    }
-	  break;
-	case FB_ACCEL:
-	  token = g_scanner_get_next_token (scanner);
-	  if (token != G_TOKEN_IDENTIFIER)
-	    {
-	      g_free (modename);
-	      return -1;
-	    }
-	  if (g_ascii_strcasecmp (scanner->value.v_identifier, "false")==0)
-	    accel = 0;
-	  else if (g_ascii_strcasecmp (scanner->value.v_identifier, "true")==0)
-	    accel = 1;
-	  else
-	    {
-	      g_free (modename);
-	      return -1;
-	    }
-	  break;
-	}
-      
-      token = g_scanner_get_next_token (scanner);
-      if (token != G_TOKEN_SYMBOL)
-	{
-	  g_free (modename);
-	  return -1; /* Not a valid keyword */
-	}
-      keyword = GPOINTER_TO_INT (scanner->value.v_symbol);
-    }
-
-  if (strcmp (modename, specified_modename)== 0) {
-    /* we really should be parsing for rgba. regardless, if rgba isn't found,
-     * we can't assume that the original colors are valid for the new mode */
-    memset (&modeinfo->red, 0, sizeof (modeinfo->red));
-    memset (&modeinfo->green, 0, sizeof (modeinfo->green));
-    memset (&modeinfo->blue, 0, sizeof (modeinfo->blue));
-    memset (&modeinfo->transp, 0, sizeof (modeinfo->transp));
-
-    if (!found_geometry)
-      g_warning ("Geometry not specified");
-
-    if (found_geometry)
-      {
-	modeinfo->xres = geometry[0];
-	modeinfo->yres = geometry[1];
-	modeinfo->xres_virtual = geometry[2];
-	modeinfo->yres_virtual = geometry[3];
-	modeinfo->bits_per_pixel = geometry[4];
-      }
-    
-    if (!found_timings)
-      g_warning ("Timing not specified");
-    
-    if (found_timings)
-      {
-	modeinfo->pixclock = timings[0];
-	modeinfo->left_margin = timings[1];
-	modeinfo->right_margin = timings[2];
-	modeinfo->upper_margin = timings[3];
-	modeinfo->lower_margin = timings[4];
-	modeinfo->hsync_len = timings[5];
-	modeinfo->vsync_len = timings[6];
-	
-	modeinfo->vmode = 0;
-	if (laced)
-	  modeinfo->vmode |= FB_VMODE_INTERLACED;
-	if (doublescan)
-	  modeinfo->vmode |= FB_VMODE_DOUBLE;
-	  
-	modeinfo->sync = 0;
-	if (hsync)
-	  modeinfo->sync |= FB_SYNC_HOR_HIGH_ACT;
-	if (vsync)
-	  modeinfo->sync |= FB_SYNC_VERT_HIGH_ACT;
-	if (accel)
-	  modeinfo->accel_flags = FB_ACCELF_TEXT;
-	else
-	  modeinfo->accel_flags = 0;
-      }
-
-    g_free (modename);
-    return 1;
-  }
-  
-  g_free (modename);
-
-  return 0;
-}
-
-static int
-gdk_fb_setup_mode_from_name (struct fb_var_screeninfo *modeinfo,
-			     char *modename)
-{
-  GScanner *scanner;
-  char *filename;
-  gint result;
-  int fd, i;
-  int retval;
-
-  retval = 0;
-  
-  filename = "/etc/fb.modes";
-  
-  fd = open (filename, O_RDONLY);
-  if (fd < 0)
-    {
-      g_warning ("Cannot read %s", filename);
-      return retval;
-    }
-  
-  scanner = g_scanner_new ((GScannerConfig *) &fb_modes_scanner_config);
-  scanner->input_name = filename;
-
-  for (i = 0; i < sizeof(fb_modes_keywords)/sizeof(fb_modes_keywords[0]); i++)
-    g_scanner_scope_add_symbol (scanner, 0, fb_modes_keywords[i], GINT_TO_POINTER (i));
-
-  g_scanner_input_file (scanner, fd);
-  
-  while (1) {
-    if (g_scanner_peek_next_token (scanner) == G_TOKEN_EOF) {
-      break;
-    } 
-    result = fb_modes_parse_mode (scanner, modeinfo, modename);
-      
-    if (result < 0) {
-      g_warning ("parse error in %s at line %d", filename, scanner->line);
-      break;
-    }
-    if (result > 0)
-      {
-	retval = 1;
-	break;
-      }
-  }
-  
-  g_scanner_destroy (scanner);
-  
-  close (fd);
-  
-  return retval;
-}
-  
-
-static int
-gdk_fb_set_mode (GdkFBDisplay *display)
-{
-  char *env, *end;
-  int depth, height, width;
-  gboolean changed;
-  
-  if (ioctl (display->fb_fd, FBIOGET_VSCREENINFO, &display->modeinfo) < 0)
-    return -1;
-
-  display->orig_modeinfo = display->modeinfo;
-
-  changed = FALSE;
-  
-  env = getenv ("GDK_DISPLAY_MODE");
-  if (env)
-    {
-      if (gdk_fb_setup_mode_from_name (&display->modeinfo, env))
-	changed = TRUE;
-      else
-	g_warning ("Couldn't find mode named '%s'", env);
-    }
-
-  env = getenv ("GDK_DISPLAY_DEPTH");
-  if (env)
-    {
-      depth = strtol (env, &end, 10);
-      if (env != end)
-	{
-	  changed = TRUE;
-	  display->modeinfo.bits_per_pixel = depth;
-	}
-    }
-  
-  env = getenv ("GDK_DISPLAY_WIDTH");
-  if (env)
-    {
-      width = strtol (env, &end, 10);
-      if (env != end)
-	{
-	  changed = TRUE;
-	  display->modeinfo.xres = width;
-	  display->modeinfo.xres_virtual = width;
-	}
-    }
-    
-  env = getenv ("GDK_DISPLAY_HEIGHT");
-  if (env)
-    {
-      height = strtol (env, &end, 10);
-      if (env != end)
-	{
-	  changed = TRUE;
-	  display->modeinfo.yres = height;
-	  display->modeinfo.yres_virtual = height;
-	}
-    }
-
-  if (changed &&
-      (ioctl (display->fb_fd, FBIOPUT_VSCREENINFO, &display->modeinfo) < 0))
-    {
-      g_warning ("Couldn't set specified mode");
-      return -1;
-    }
-  
-  /* ask for info back to make sure of what we got */
-  if (ioctl (display->fb_fd, FBIOGET_VSCREENINFO, &display->modeinfo) < 0)
-    {
-      g_warning ("Error getting var screen info");
-      return -1;
-    }
-  
-  if (ioctl (display->fb_fd, FBIOGET_FSCREENINFO, &display->sinfo) < 0)
-    {
-      g_warning ("Error getting fixed screen info");
-      return -1;
-    }
-  return 0;
-}
-
-#ifdef ENABLE_FB_MANAGER
-static void
-gdk_fb_switch_from (void)
-{
-  g_print ("Switch from\n");
-  gdk_shadow_fb_stop_updates ();
-  gdk_fb_mouse_close ();
-  gdk_fb_keyboard_close ();
-}
-
-static void
-gdk_fb_switch_to (void)
-{
-  g_print ("switch_to\n");
-  gdk_shadow_fb_update (0, 0, 
-			gdk_display->fb_width, 
-			gdk_display->fb_height);
-
-  if (!gdk_fb_keyboard_open ())
-    g_warning ("Failed to re-initialize keyboard");
-  
-  if (!gdk_fb_mouse_open ())
-    g_warning ("Failed to re-initialize mouse");
-
-}
-
-
-static gboolean
-gdk_fb_manager_callback (GIOChannel *gioc,
-			 GIOCondition cond,
-			 gpointer data)
-{
-  struct FBManagerMessage msg;
-  GdkFBDisplay *display;
-  int res;
-
-  display = data;
-
-  res = recv (display->manager_fd, &msg, sizeof (msg), 0);
-
-  if (res==0)
-    {
-      g_source_remove (gdk_display->manager_tag);
-      /*g_io_channel_unref (kb->io);*/
-      close (gdk_display->manager_fd);
-
-    }
-
-  if (res != sizeof (msg))
-    {
-      g_warning ("Got wrong size message");
-      return TRUE;
-    }
-  
-  switch (msg.msg_type)
-    {
-    case FB_MANAGER_SWITCH_FROM:
-      g_print ("Got switch from message\n");
-      display->manager_blocked = TRUE;
-      gdk_fb_switch_from ();
-      msg.msg_type = FB_MANAGER_ACK;
-      send (display->manager_fd, &msg, sizeof (msg), 0);
-      break;
-    case FB_MANAGER_SWITCH_TO:
-      g_print ("Got switch to message\n");
-      display->manager_blocked = FALSE;
-      gdk_fb_switch_to ();
-      break;
-    default:
-      g_warning ("Got unknown message");
-    }
-  return TRUE;
-}
-
-#endif /* ENABLE_FB_MANAGER */
-
-static void
-gdk_fb_manager_connect (GdkFBDisplay *display)
-{
-#ifdef ENABLE_FB_MANAGER
-  int fd;
-  struct sockaddr_un addr;
-  struct msghdr msg = {0};
-  struct cmsghdr *cmsg;
-  struct ucred credentials;
-  struct FBManagerMessage init_msg;
-  struct iovec iov;
-  char buf[CMSG_SPACE (sizeof (credentials))];  /* ancillary data buffer */
-  int *fdptr;
-  int res;
-
-  display->manager_blocked = FALSE;
-  display->manager_fd = -1;
-
-  fd = socket (PF_UNIX, SOCK_STREAM, 0);
-  
-  g_print ("socket: %d\n", fd);
-
-  if (fd < 0)
-    return;
-
-  addr.sun_family = AF_UNIX;
-  strcpy (addr.sun_path, "/tmp/.fb.manager");
-
-  if (connect(fd, (struct sockaddr *)&addr, sizeof (addr)) < 0) 
-    {
-      g_print ("connect failed\n");
-      close (fd);
-      return;
-    }
-  
-  credentials.pid = getpid ();
-  credentials.uid = geteuid ();
-  credentials.gid = getegid ();
-
-  init_msg.msg_type = FB_MANAGER_NEW_CLIENT;
-  iov.iov_base = &init_msg;
-  iov.iov_len = sizeof (init_msg);
-
-  msg.msg_name = NULL;
-  msg.msg_namelen = 0;
-  msg.msg_iov = &iov;
-  msg.msg_iovlen = 1;
-  msg.msg_control = buf;
-  msg.msg_controllen = sizeof buf;
-  cmsg = CMSG_FIRSTHDR(&msg);
-  cmsg->cmsg_level = SOL_SOCKET;
-  cmsg->cmsg_type = SCM_CREDENTIALS;
-  cmsg->cmsg_len = CMSG_LEN (sizeof (credentials));
-  /* Initialize the payload: */
-  fdptr = (int *)CMSG_DATA (cmsg);
-  memcpy (fdptr, &credentials, sizeof (credentials));
-  /* Sum of the length of all control messages in the buffer: */
-  msg.msg_controllen = cmsg->cmsg_len;
-
-  res = sendmsg (fd, &msg, 0);
-
-  display->manager_fd = fd;
-  display->manager_blocked = TRUE;
-
-  display->manager_tag = g_io_add_watch (g_io_channel_unix_new (fd),
-					 G_IO_IN | G_IO_ERR | G_IO_HUP | G_IO_NVAL,
-					 gdk_fb_manager_callback,
-					 display);
-
-  init_msg.msg_type = FB_MANAGER_REQUEST_SWITCH_TO_PID;
-  init_msg.data = getpid ();
-
-  /* Request a switch-to */
-  send (fd, &init_msg, sizeof (init_msg), 0);
-#endif
-}
-
-static void
-gdk_fb_switch (int sig)
-{
-  if (sig == SIGUSR1)
-    {
-      ioctl (gdk_display->tty_fd, VT_RELDISP, 1);
-      _gdk_fb_is_active_vt = FALSE;
-      gdk_shadow_fb_stop_updates ();
-      gdk_fb_mouse_close ();
-      gdk_fb_keyboard_close ();
-    }
-  else
-    {
-      GdkColormap *cmap;
-      ioctl (gdk_display->tty_fd, VT_RELDISP, VT_ACKACQ);
-      _gdk_fb_is_active_vt = TRUE;
-
-      /* XXX: is it dangerous to put all this stuff in a signal handler? */
-      cmap = gdk_screen_get_default_colormap (_gdk_screen);
-      gdk_colormap_change (cmap, cmap->size);
-
-      gdk_shadow_fb_update (0, 0,
-			    gdk_display->fb_width,
-			    gdk_display->fb_height);
 
-      if (!gdk_fb_keyboard_open ())
-        g_warning ("Failed to re-initialize keyboard");
-
-      if (!gdk_fb_mouse_open ())
-        g_warning ("Failed to re-initialize mouse");
-
-      gdk_fb_redraw_all ();
-    }
-}
-
-static GdkFBDisplay *
-gdk_fb_display_new ()
+static GdkFBDisplay * gdk_fb_display_new ()
 {
-  GdkFBDisplay *display;
-  gchar *fb_filename;
-  struct vt_stat vs;
-  struct vt_mode vtm;
-  int vt, n;
-  gchar *s, *send;
-  char buf[32];
-
-  display = g_new0 (GdkFBDisplay, 1);
-
-  display->console_fd = open ("/dev/console", O_RDWR);
-  if (display->console_fd < 0)
-    {
-      g_warning ("Can't open /dev/console: %s", strerror (errno));
-      g_free (display);
-      return NULL;
-    }
-  
-  ioctl (display->console_fd, VT_GETSTATE, &vs);
-  display->start_vt = vs.v_active;
-
-  vt = display->start_vt;
-  s = getenv("GDK_VT");
-  if (s)
-    {
-      if (g_ascii_strcasecmp ("new", s)==0)
-	{
-	  n = ioctl (display->console_fd, VT_OPENQRY, &vt);
-	  if (n < 0 || vt == -1)
-	    g_error("Cannot allocate new VT");
-	}
-      else
-	{
-	  vt = strtol (s, &send, 10);
-	  if (s==send)
-	    {
-	      g_warning ("Cannot parse GDK_VT");
-	      vt = display->start_vt;
-	    }
-	}
-      
-    }
-
-  display->vt = vt;
-  
-  /* Switch to the new VT */
-  if (vt != display->start_vt)
-    {
-      ioctl (display->console_fd, VT_ACTIVATE, vt);
-      ioctl (display->console_fd, VT_WAITACTIVE, vt);
-    }
-  
-  /* Open the tty */
-  g_snprintf (buf, sizeof(buf), "/dev/tty%d", vt);
-  display->tty_fd = open (buf, O_RDWR|O_NONBLOCK);
-  if (display->tty_fd < 0)
-    {
-      g_warning ("Can't open %s: %s", buf, strerror (errno));
-      close (display->console_fd);
-      g_free (display);
-      return NULL;
-    }
+	s_window_t *window;
+	GdkFBDisplay *display;
 
-  /* set up switch signals */
-  if (ioctl (display->tty_fd, VT_GETMODE, &vtm) >= 0)
-    {
-      signal (SIGUSR1, gdk_fb_switch);
-      signal (SIGUSR2, gdk_fb_switch);
-      vtm.mode = VT_PROCESS;
-      vtm.waitv = 0;
-      vtm.relsig = SIGUSR1;
-      vtm.acqsig = SIGUSR2;
-      ioctl (display->tty_fd, VT_SETMODE, &vtm);
-    }
-  _gdk_fb_is_active_vt = TRUE;
-  
-  fb_filename = gdk_get_display ();
-  display->fb_fd = open (fb_filename, O_RDWR);
-  if (display->fb_fd < 0)
-    {
-      g_warning ("Can't open %s: %s", fb_filename, strerror (errno));
-      g_free (fb_filename);
-      close (display->tty_fd);
-      close (display->console_fd);
-      g_free (display);
-      return NULL;
-    }
-  g_free (fb_filename);
+	display = g_new0(GdkFBDisplay, 1);
 
-  if (gdk_fb_set_mode (display) < 0)
-    {
-      close (display->fb_fd);
-      close (display->tty_fd);
-      close (display->console_fd);
-      g_free (display);
-      return NULL;
-    }
-
-  /* Disable normal text on the console */
-  ioctl (display->fb_fd, KDSETMODE, KD_GRAPHICS);
-
-  ioctl (display->fb_fd, FBIOBLANK, 0);
-
-  /* We used to use sinfo.smem_len, but that seemed to be broken in many cases */
-  display->fb_mmap = mmap (NULL,
-			   display->modeinfo.yres * display->sinfo.line_length,
-			   PROT_READ|PROT_WRITE,
-			   MAP_SHARED,
-			   display->fb_fd,
-			   0);
-  g_assert (display->fb_mmap != MAP_FAILED);
-
-  if (display->sinfo.visual == FB_VISUAL_TRUECOLOR)
-    {
-      display->red_byte = display->modeinfo.red.offset >> 3;
-      display->green_byte = display->modeinfo.green.offset >> 3;
-      display->blue_byte = display->modeinfo.blue.offset >> 3;
-    }
+	s_window_init(&window);
+	s_window_new(window, WINDOW_MAIN | WINDOW_NOFORM, NULL);
+	s_window_set_coor(window, 0, 0, 0, window->surface->width, window->surface->height);
+
+	display->modeinfo.red.length		= window->surface->redlength;
+	display->modeinfo.green.length		= window->surface->greenlength;
+	display->modeinfo.blue.length		= window->surface->bluelength;
+	display->modeinfo.red.offset		= window->surface->redoffset;
+	display->modeinfo.green.offset		= window->surface->greenoffset;
+	display->modeinfo.blue.offset		= window->surface->blueoffset;
+	display->modeinfo.bits_per_pixel	= window->surface->bitsperpixel;
+	display->modeinfo.xres			= window->surface->width;
+	display->modeinfo.yres			= window->surface->height;
+	display->modeinfo.xres_virtual		= window->surface->width;
+	display->modeinfo.yres_virtual		= window->surface->height;
+	display->sinfo.line_length		= window->surface->width * window->surface->bytesperpixel;
+	display->sinfo.smem_len			= window->surface->width * window->surface->bytesperpixel;
+	display->sinfo.visual			= FB_VISUAL_TRUECOLOR;
+
+	display->fb_mmap = window->surface->vbuf;
+
+	display->red_byte = display->modeinfo.red.offset >> 3;
+	display->green_byte = display->modeinfo.green.offset >> 3;
+	display->blue_byte = display->modeinfo.blue.offset >> 3;
 
 #ifdef ENABLE_SHADOW_FB
-  if (_gdk_fb_screen_angle % 2 == 0)
-    {
-      display->fb_width = display->modeinfo.xres;
-      display->fb_height = display->modeinfo.yres;
-    } 
-  else
-    {
-      display->fb_width = display->modeinfo.yres;
-      display->fb_height = display->modeinfo.xres;
-    }
-  display->fb_stride =
-    display->fb_width * (display->modeinfo.bits_per_pixel / 8);
-  display->fb_mem = g_malloc(display->fb_height * display->fb_stride);
+	if (_gdk_fb_screen_angle % 2 == 0) {
+		display->fb_width = display->modeinfo.xres;
+		display->fb_height = display->modeinfo.yres;
+	} else {
+		display->fb_width = display->modeinfo.yres;
+		display->fb_height = display->modeinfo.xres;
+	}
+	display->fb_stride = display->sinfo.line_length;
+	display->fb_mem = g_malloc(display->fb_height * display->fb_stride);
 #else
-  display->fb_mem = display->fb_mmap;
-  display->fb_width = display->modeinfo.xres;
-  display->fb_height = display->modeinfo.yres;
-  display->fb_stride = display->sinfo.line_length;
+	display->fb_mem = display->fb_mmap;
+	display->fb_width = display->modeinfo.xres;
+	display->fb_height = display->modeinfo.yres;
+	display->fb_stride = display->sinfo.line_length;
 #endif
+	s_thread_create(&s_window_loop, window);
 
-  return display;
+        display->xynth_root = window;
+	
+	return display;
 }
 
 static void
@@ -898,8 +169,6 @@
 
   gdk_shadow_fb_init ();
   
-  gdk_fb_manager_connect (gdk_display);
-
   if (!gdk_fb_keyboard_init (!gdk_display->manager_blocked))
     {
       g_warning ("Failed to initialize keyboard");
@@ -907,11 +176,10 @@
       gdk_display = NULL;
       return;
     }
-  
+
   if (!gdk_fb_mouse_init (!gdk_display->manager_blocked))
     {
       g_warning ("Failed to initialize mouse");
-      gdk_fb_keyboard_close ();
       gdk_fb_display_destroy (gdk_display);
       gdk_display = NULL;
       return;
@@ -1309,9 +577,6 @@
   gdk_fb_mouse_close ();
   /*leak  g_free (gdk_fb_mouse);*/
   
-  gdk_fb_keyboard_close ();
-  /*leak g_free (gdk_fb_keyboard);*/
-  
   gdk_fb_display_destroy (gdk_display);
   
   gdk_display = NULL;
diff -Naur gtk+-2.4.14/gdk/linux-fb/gdkmouse-fb.c gtk+-2.4.14-xynth/gdk/linux-fb/gdkmouse-fb.c
--- gtk+-2.4.14/gdk/linux-fb/gdkmouse-fb.c	2004-03-06 05:37:04.000000000 +0200
+++ gtk+-2.4.14-xynth/gdk/linux-fb/gdkmouse-fb.c	2006-12-12 12:48:04.000000000 +0200
@@ -16,6 +16,12 @@
  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA.
  */
+ 
+/*
+ * Gtk-Xynth port is based on linux-fb port
+ * Xynth Team
+ * http://www.xynth.org
+ */
 
 #include <config.h>
 #include <gdk/gdk.h>
@@ -33,24 +39,11 @@
 #include <errno.h>
 
 typedef struct _GdkFBMouse GdkFBMouse;
-typedef struct _GdkFBMouseDevice GdkFBMouseDevice;
 
 struct _GdkFBMouse {
-  gint fd; /* Set by open */
-  gchar *file;
-
-  /* These are written to by parse_packet */
   gdouble x, y;
   gboolean button_pressed[3];
-
-  guchar mouse_packet[5]; /* read by parse_packet */
-  gint packet_nbytes;
-  
   gboolean click_grab;
-  GIOChannel *io;
-  gint io_tag;
-
-  GdkFBMouseDevice *dev;
 };
 
 static GdkFBMouse *gdk_fb_mouse = NULL;
@@ -244,621 +237,57 @@
   _gdk_event_queue_append (gdk_display_get_default (), event);
 }
 
-/******************************************************
- ************ Device specific mouse code **************
- ******************************************************/
-
-/* proto is used to detect the start of the packet:
- *   (buf[0]&proto[0]) == proto[1]
- * indicates start of packet.
- */
-
-struct _GdkFBMouseDevice {
-  gchar *name;
-  gchar *file;
-  gint packet_size;
-  gboolean (*open)(GdkFBMouse *mouse);
-  void (*close)(GdkFBMouse *mouse);
-  gboolean (*parse_packet)(GdkFBMouse *mouse, gboolean *got_motion);
-  guchar proto[2];
-};
-
-static gboolean handle_mouse_io             (GIOChannel   *gioc,
-					     GIOCondition  cond,
-					     gpointer      data);
-static gboolean gdk_fb_mouse_ps2_open       (GdkFBMouse   *mouse);
-static gboolean gdk_fb_mouse_imps2_open     (GdkFBMouse   *mouse);
-static void     gdk_fb_mouse_ps2_close      (GdkFBMouse   *mouse);
-static gboolean gdk_fb_mouse_ps2_packet     (GdkFBMouse   *mouse,
-					     gboolean     *got_motion);
-static gboolean gdk_fb_mouse_ms_open        (GdkFBMouse   *mouse);
-static void     gdk_fb_mouse_ms_close       (GdkFBMouse   *mouse);
-static gboolean gdk_fb_mouse_ms_packet      (GdkFBMouse   *mouse,
-					     gboolean     *got_motion);
-static gboolean gdk_fb_mouse_fidmour_open   (GdkFBMouse   *mouse);
-static void     gdk_fb_mouse_fidmour_close  (GdkFBMouse   *mouse);
-static gboolean gdk_fb_mouse_fidmour_packet (GdkFBMouse   *mouse,
-					     gboolean     *got_motion);
-
-static GdkFBMouseDevice mouse_devs[] =
-{
-  { "ps2",
-    "/dev/psaux",
-    3,
-    gdk_fb_mouse_ps2_open,
-    gdk_fb_mouse_ps2_close,
-    gdk_fb_mouse_ps2_packet,
-    { 0xc0, 0x00 }
-  },
-  { "imps2",
-    "/dev/psaux",
-    4,
-    gdk_fb_mouse_imps2_open,
-    gdk_fb_mouse_ps2_close,
-    gdk_fb_mouse_ps2_packet,
-    { 0xc0, 0x00 }
-  },
-  { "ms",
-    "/dev/mouse",
-    3,
-    gdk_fb_mouse_ms_open,
-    gdk_fb_mouse_ms_close,
-    gdk_fb_mouse_ms_packet,
-    { 0x40, 0x40 }
-  },
-  { "fidmour",
-    "/dev/fidmour",
-    5,
-    gdk_fb_mouse_fidmour_open,
-    gdk_fb_mouse_fidmour_close,
-    gdk_fb_mouse_fidmour_packet,
-    { 0x00, 0x00 } /* don't know what packet start looks like */
-  }
-};
-
-gboolean
-gdk_fb_mouse_init (gboolean open_dev)
-{
-  gchar *mouse_type, *mouse_file;
-  gint i;
-
-  gdk_fb_mouse = g_new0 (GdkFBMouse, 1);
-  gdk_fb_mouse->fd = -1;
-
-  mouse_type = getenv ("GDK_MOUSE_TYPE");
-  if (!mouse_type)
-    mouse_type = "ps2";
-      
-  for (i=0;i<G_N_ELEMENTS(mouse_devs);i++)
-    {
-      if (g_ascii_strcasecmp(mouse_type, mouse_devs[i].name)==0)
-	break;
-    }
-  
-  if (i == G_N_ELEMENTS(mouse_devs))
-    {
-      g_warning ("No mouse driver of type %s found", mouse_type);
-      return FALSE;
-    }
-
-  gdk_fb_mouse->dev = &mouse_devs[i];
-
-  mouse_file = getenv ("GDK_MOUSE_FILE");
-  if (!mouse_file)
-    mouse_file = gdk_fb_mouse->dev->file;
-  gdk_fb_mouse->file = mouse_file;
-
-  gdk_fb_mouse->x = gdk_display->fb_width / 2;
-  gdk_fb_mouse->y = gdk_display->fb_height / 2;
-
-  if (open_dev)
-    return gdk_fb_mouse_open ();
-  else
-    return TRUE;
-}
-
-gboolean
-gdk_fb_mouse_open (void)
-{
-  GdkFBMouseDevice *device;
-
-  device = gdk_fb_mouse->dev;
-
-  if (!device->open(gdk_fb_mouse))
-    {
-      g_warning ("Mouse driver open failed");
-      return FALSE;
-    }
-
-  gdk_fb_mouse->io = 
-    g_io_channel_unix_new (gdk_fb_mouse->fd);
-  gdk_fb_mouse->io_tag = 
-    g_io_add_watch (gdk_fb_mouse->io,
-		    G_IO_IN|G_IO_ERR|G_IO_HUP|G_IO_NVAL, 
-		    handle_mouse_io, gdk_fb_mouse);
-
-  return TRUE;
-}
-
-void 
-gdk_fb_mouse_close (void)
-{
-  if (gdk_fb_mouse->io_tag)
-    {
-      g_source_remove (gdk_fb_mouse->io_tag);
-      gdk_fb_mouse->io_tag = 0;
-    }
-     
- gdk_fb_mouse->dev->close(gdk_fb_mouse);
-
- if (gdk_fb_mouse->io)
-   {
-     g_io_channel_unref (gdk_fb_mouse->io);
-     gdk_fb_mouse->io = NULL;
-   }
-}
-
-static gboolean
-handle_mouse_io (GIOChannel *gioc,
-		 GIOCondition cond,
-		 gpointer data)
-{
-  GdkFBMouse *mouse = (GdkFBMouse *)data;
-  GdkFBMouseDevice *dev = mouse->dev;
-  guchar *proto = dev->proto;
-  gboolean got_motion;
-  gint n, i;
-
-  got_motion = FALSE;
-  
-  while (1)
-    {
-      n = read (mouse->fd, mouse->mouse_packet + mouse->packet_nbytes, dev->packet_size - mouse->packet_nbytes);
-      if (n<=0) /* error or nothing to read */
-	break;
-
-      /* we just read in what should be the first byte of a packet */
-      if (mouse->packet_nbytes == 0)
-	{
-	  /* check to see if we have the first byte of a packet.
-	   * if not, throw it away */
-	  while ((mouse->mouse_packet[0] & proto[0]) != proto[1] && n > 0)
-	    {
-	      for (i = 1; i < n; i++)
-		mouse->mouse_packet[i-1] = mouse->mouse_packet[i];
-	      n--;
-	    }
-	  /* if none of the bytes read were packet starts, break */
-	  if (n <= 0)
-	    break;
-	}
-  
-      mouse->packet_nbytes += n;
-      
-      if (mouse->packet_nbytes == dev->packet_size)
-	{
-	  if (dev->parse_packet (mouse, &got_motion))
-	    mouse->packet_nbytes = 0;
-	}
-    }
-  
-  if (got_motion)
-    handle_mouse_movement (mouse);
-  
-  return TRUE;
-}
-
-static gint
-gdk_fb_mouse_dev_open (char *devname, gint mode)
-{
-  gint fd;
-  
-  /* Use nonblocking mode to open, to not hang on device */
-  fd = open (devname, mode | O_NONBLOCK);
-  return fd;
-}
-
-static gboolean
-write_all (gint   fd,
-	   gchar *buf,
-	   gsize  to_write)
-{
-  while (to_write > 0)
-    {
-      gssize count = write (fd, buf, to_write);
-      if (count < 0)
-	{
-	  if (errno != EINTR)
-	    return FALSE;
-	}
-      else
-	{
-	  to_write -= count;
-	  buf += count;
-	}
-    }
-
-  return TRUE;
-}
-
-static gboolean
-gdk_fb_mouse_ps2_open (GdkFBMouse *mouse)
-{
-  gint fd;
-  guchar buf[7];
-  int i = 0;
-
-  fd = gdk_fb_mouse_dev_open (mouse->file, O_RDWR);
-  if (fd < 0)
-    {
-      g_print ("Error opening %s: %s\n", mouse->file, strerror (errno));
-      return FALSE;
-    }
-
-  /* From xf86_Mouse.c */
-  buf[i++] = 230; /* 1:1 scaling */
-  buf[i++] = 244; /* enable mouse */
-  buf[i++] = 243; /* Sample rate */
-  buf[i++] = 200;
-  buf[i++] = 232; /* device resolution */
-  buf[i++] = 1;
-
-  if (!write_all (fd, buf, i))
-    {
-      close (fd);
-      return FALSE;
-    }
-  
-  usleep (10000); /* sleep 10 ms, then read whatever junk we can get from the mouse, in a vain attempt
-		     to get synchronized with the event stream */
-  
-  while ((i = read (fd, buf, sizeof(buf))) > 0)
-    g_print ("Got %d bytes of junk from psaux\n", i);
-  
-  mouse->fd = fd;
-  return TRUE;
-}
-
-static gboolean
-gdk_fb_mouse_imps2_open (GdkFBMouse *mouse)
-{
-  gint fd;
-  guchar buf[7];
-  int i = 0;
-
-  fd = gdk_fb_mouse_dev_open (mouse->file, O_RDWR);
-  if (fd < 0)
-    {
-      g_print ("Error opening %s: %s\n", mouse->file, strerror (errno));
-      return FALSE;
-    }
-
-  i = 0;
-  buf[i++] = 243; /* Sample rate */
-  buf[i++] = 200;
-  buf[i++] = 243; /* Sample rate */
-  buf[i++] = 100;
-  buf[i++] = 243; /* Sample rate */
-  buf[i++] = 80;
-  buf[i++] = 242;
-
-  if (!write_all (fd, buf, i))
-    {
-      close (fd);
-      return FALSE;
-    }
-
-  if (read (fd, buf, 1) != 1)
-    {
-      close (fd);
-      return FALSE;
-    }
-  
-  i = 0;
-  buf[i++] = 230; /* 1:1 scaling */
-  buf[i++] = 244; /* enable mouse */
-  buf[i++] = 243; /* Sample rate */
-  buf[i++] = 100;
-  buf[i++] = 232; /* device resolution */
-  buf[i++] = 3;
-
-  if (!write_all (fd, buf, i))
-    {
-      close (fd);
-      return FALSE;
-    }
-  
-  mouse->fd = fd;
-  return TRUE;
-}
-
-static void
-gdk_fb_mouse_ps2_close (GdkFBMouse *mouse)
-{
-  close (mouse->fd);
-  mouse->fd = -1;
-}
-
-static gboolean
-gdk_fb_mouse_ps2_packet (GdkFBMouse *mouse, gboolean *got_motion)
-{
-  int dx=0, dy=0;
-  gboolean new_button1, new_button2, new_button3;
-  guchar *buf;
-
-  buf = mouse->mouse_packet;
-      
-  new_button1 = (buf[0] & 1) && 1;
-  new_button3 = (buf[0] & 2) && 1;
-  new_button2 = (buf[0] & 4) && 1;
-  if (mouse->dev->packet_size == 4 && buf[3] != 0)
-    handle_mouse_scroll (mouse, buf[3] & 0x80);
-
-  if (*got_motion &&
-      (new_button1 != mouse->button_pressed[0] ||
-       new_button2 != mouse->button_pressed[1] ||
-       new_button3 != mouse->button_pressed[2]))
-    {
-      /* If a mouse button state changes we need to get correct ordering with enter/leave events,
-	 so push those out via handle_mouse_input */
-      *got_motion = FALSE;
-      handle_mouse_movement (mouse);
-    }
-
-  if (new_button1 != mouse->button_pressed[0])
-    {
-      mouse->button_pressed[0] = new_button1; 
-      send_button_event (mouse, 1, new_button1);
-    }
-  
-  if (new_button2 != mouse->button_pressed[1])
-    {
-      mouse->button_pressed[1] = new_button2;
-      send_button_event (mouse, 2, new_button2);
-    }
-  
-  if (new_button3 != mouse->button_pressed[2])
-    {
-      mouse->button_pressed[2] = new_button3; 
-      send_button_event (mouse, 3, new_button3);
-    }
-      
-  if (buf[1] != 0)
-    dx = ((buf[0] & 0x10) ? ((gint)buf[1])-256 : buf[1]);
-  else
-    dx = 0;
-  if (buf[2] != 0)
-    dy = -((buf[0] & 0x20) ? ((gint)buf[2])-256 : buf[2]);
-  else
-    dy = 0;
-  
-  mouse->x += dx;
-  mouse->y += dy;
-  
-  if (dx || dy)
-    *got_motion = TRUE;
-
-  return TRUE;
-}
-
-
-static gboolean
-gdk_fb_mouse_ms_open (GdkFBMouse   *mouse)
-{
-  gint fd;
-  gint i;
-  guchar buf[7];
-  struct termios tty;
-
-  fd = gdk_fb_mouse_dev_open (mouse->file, O_RDWR);
-  if (fd < 0)
-    {
-      g_print ("Error opening %s: %s\n", mouse->file, strerror (errno));
-      return FALSE;
-    }
-
-  while ((i = read (fd, buf, sizeof(buf))) > 0)
-    g_print ("Got %d bytes of junk from %s\n", mouse->file, i);
-
-  tcgetattr (fd, &tty);
-  tty.c_iflag = IGNBRK | IGNPAR;
-  tty.c_cflag = CREAD|CLOCAL|HUPCL|CS7|B1200;
-  tty.c_oflag = 0;
-  tty.c_lflag = 0;
-  tty.c_line = 0;
-  tty.c_cc[VTIME] = 0;
-  tty.c_cc[VMIN] = 1;
-  tcsetattr (fd, TCSAFLUSH, &tty);
-
-  if (!write_all (fd, "*n", 2))
-    {
-      close (fd);
-      return FALSE;
-    }
-
-  mouse->fd = fd;
-  return TRUE;
-}
-
-static void
-gdk_fb_mouse_ms_close (GdkFBMouse   *mouse)
-{
-  close (mouse->fd);
-  mouse->fd = -1;
-}
-
-static gboolean
-gdk_fb_mouse_ms_packet (GdkFBMouse   *mouse,
-			gboolean     *got_motion)
-{
-  int dx=0, dy=0;
-  gboolean new_button1, new_button2, new_button3;
-  guchar *buf;
-  static guchar prev = 0;
-
-  buf = mouse->mouse_packet;
-
-  /* handling of third button is adapted from gpm ms driver */
-  if (buf[0] == 0x40 && !(prev|buf[1]|buf[2]))
-    {
-      new_button1 = 0;
-      new_button2 = 1;
-      new_button3 = 0;
-    }
-  else
-    {
-      new_button1 = (buf[0] & 0x20) && 1;
-      new_button2 = 0;
-      new_button3 = (buf[0] & 0x10) && 1;
-    }
-  prev = (new_button1 << 2) | (new_button2 << 1) | (new_button3 << 0);
-
-  if (*got_motion &&
-      (new_button1 != mouse->button_pressed[0] ||
-       new_button2 != mouse->button_pressed[1] ||
-       new_button3 != mouse->button_pressed[2]))
-    {
-      /* If a mouse button state changes we need to get correct ordering with enter/leave events,
-	 so push those out via handle_mouse_input */
-      *got_motion = FALSE;
-      handle_mouse_movement (mouse);
-    }
-
-  if (new_button1 != mouse->button_pressed[0])
-    {
-      mouse->button_pressed[0] = new_button1; 
-      send_button_event (mouse, 1, new_button1);
-    }
-  
-  if (new_button2 != mouse->button_pressed[1])
-    {
-      mouse->button_pressed[1] = new_button2;
-      send_button_event (mouse, 2, new_button2);
-    }
-  
-  if (new_button3 != mouse->button_pressed[2])
-    {
-      mouse->button_pressed[2] = new_button3; 
-      send_button_event (mouse, 3, new_button3);
-    }
-
-  dx = (signed char)(((buf[0] & 0x03) << 6) | (buf[1] & 0x3F));
-  dy = (signed char)(((buf[0] & 0x0C) << 4) | (buf[2] & 0x3F));
-  
-  mouse->x += dx;
-  mouse->y += dy;
-  
-  if (dx || dy)
-    *got_motion = TRUE;
-
-  return TRUE;
-}
-
-static gboolean
-gdk_fb_mouse_fidmour_open (GdkFBMouse   *mouse)
+gboolean gdk_fb_mouse_init (gboolean open_dev)
 {
-  gint fd;
-
-  fd = gdk_fb_mouse_dev_open (mouse->file, O_RDONLY);
-  if (fd < 0)
-    {
-      g_print ("Error opening %s: %s\n", mouse->file, strerror (errno));
-      return FALSE;
-    }
-
-  mouse->fd = fd;
-  return TRUE;
-}
-
-static void
-gdk_fb_mouse_fidmour_close (GdkFBMouse   *mouse)
+	gdk_fb_mouse = g_new0 (GdkFBMouse, 1);
+	gdk_fb_mouse->x = gdk_display->fb_width / 2;
+	gdk_fb_mouse->y = gdk_display->fb_height / 2;
+	return TRUE;
+}
+
+gboolean gdk_fb_mouse_open (void)
+{
+	return TRUE;
+}
+
+void gdk_fb_mouse_close (void)
 {
-  close (mouse->fd);
 }
 
-static gboolean
-gdk_fb_mouse_fidmour_packet (GdkFBMouse   *mouse,
-			     gboolean     *got_motion)
-{
-  int n;
-  gboolean btn_down = 0;
-  gdouble x = 0.0, y = 0.0;
-
-  n = 0;
-  if (!(mouse->mouse_packet[0] & 0x80))
-    {
-      int i;
-      /* We haven't received any of the packet yet but there is no header at the beginning */
-      for (i = 1; i < mouse->packet_nbytes; i++)
-	{
-	  if (mouse->mouse_packet[i] & 0x80)
-	    {
-	      n = i;
-	      break;
-	    }
-	}
-    }
-  else if (mouse->packet_nbytes > 1 &&
-	   ((mouse->mouse_packet[0] & 0x90) == 0x90))
-    {
-      /* eat the 0x90 and following byte, no clue what it's for */
-      n = 2;
-    }
-  else
-    {
-      switch (mouse->mouse_packet[0] & 0xF)
-	{
-	case 2:
-	  btn_down = 0;
-	  break;
-	case 1:
-	case 0:
-	  btn_down = 1;
-	  break;
-	default:
-	  g_assert_not_reached ();
-	  break;
-	}
-      
-      x = mouse->mouse_packet[1] + (mouse->mouse_packet[2] << 7);
-      if (x > 8192)
-	x -= 16384;
-      y = mouse->mouse_packet[3] + (mouse->mouse_packet[4] << 7);
-      if (y > 8192)
-	y -= 16384;
-      /* Now map touchscreen coords to screen coords */
-      x *= ((double)gdk_display->fb_width)/4096.0;
-      y *= ((double)gdk_display->fb_height)/4096.0;
-    }
-  
-  if (n)
-    {
-      memmove (mouse->mouse_packet, mouse->mouse_packet+n, mouse->packet_nbytes-n);
-      mouse->packet_nbytes -= n;
-      return FALSE;
-    }
-
-  if (btn_down != mouse->button_pressed[0])
-    {
-      if (*got_motion)
-	{
-	  /* If a mouse button state changes we need to get correct
-	     ordering with enter/leave events, so push those out
-	     via handle_mouse_input */
-	  *got_motion = FALSE;
-	  handle_mouse_movement (mouse);
+void gdk_s_handler_mouse_ (s_event_t *event)
+{
+        int state = 0;
+        int button = 0;
+        
+	if (event->type & MOUSE_OVER) {
+		gdk_fb_mouse->x = event->mouse->x;
+		gdk_fb_mouse->y = event->mouse->y;
+		handle_mouse_movement(gdk_fb_mouse);
+	} else if (event->type & (MOUSE_PRESSED | MOUSE_RELEASED | MOUSE_CLICKED)) {
+		if (event->type & (MOUSE_PRESSED)) {
+			state = 1;
+		}
+		if (event->type & (MOUSE_RELEASED | MOUSE_CLICKED)) {
+			state = 0;
+		}
+		switch (event->mouse->b) {
+			case 1: /* right button  */
+				button = 3;
+				break;
+			case 2: /* middle button */
+				button = 2;
+				break;
+			case 4: /* left button   */
+				button = 1;
+				break;
+		}
+		gdk_fb_mouse->button_pressed[1] = event->mouse->buttons & 4;
+		gdk_fb_mouse->button_pressed[2] = event->mouse->buttons & 2;
+		gdk_fb_mouse->button_pressed[3] = event->mouse->buttons & 1;
+		if (state) {
+			send_button_event(gdk_fb_mouse, button, state);
+		}
+		send_button_event(gdk_fb_mouse, button, state);
+		handle_mouse_movement(gdk_fb_mouse);
 	}
-      
-      mouse->button_pressed[0] = btn_down;
-      send_button_event (mouse, 1, btn_down);
-    }
-  
-  if (fabs(x - mouse->x) >= 1.0 || fabs(x - mouse->y) >= 1.0)
-    {
-      *got_motion = TRUE;
-      mouse->x = x;
-      mouse->y = y;
-    }
-  
-  return TRUE;
 }
diff -Naur gtk+-2.4.14/gdk/linux-fb/gdkprivate-fb.h gtk+-2.4.14-xynth/gdk/linux-fb/gdkprivate-fb.h
--- gtk+-2.4.14/gdk/linux-fb/gdkprivate-fb.h	2004-07-28 19:06:54.000000000 +0300
+++ gtk+-2.4.14-xynth/gdk/linux-fb/gdkprivate-fb.h	2006-12-12 13:00:51.000000000 +0200
@@ -28,6 +28,12 @@
  * Private uninstalled header defining things local to X windowing code
  */
 
+/*
+ * Gtk-Xynth port is based on linux-fb port
+ * Xynth Team
+ * http://www.xynth.org
+ */
+
 #ifndef __GDK_PRIVATE_FB_H__
 #define __GDK_PRIVATE_FB_H__
 
@@ -38,8 +44,9 @@
 #include "gdkregion-generic.h"
 #include <linux/fb.h>
 #include <stdio.h>
-#include <ft2build.h>
-#include FT_FREETYPE_H
+#include <freetype/freetype.h>
+
+#include <xynth.h>
 
 #define GDK_TYPE_DRAWABLE_IMPL_FBDATA (gdk_drawable_impl_fb_get_type ())
 #define GDK_DRAWABLE_IMPL_FBDATA(win) ((GdkDrawableFBData *)((GdkWindowObject *)(win))->impl)
@@ -88,6 +95,10 @@
   gint width, height, depth;
   GdkColormap *colormap;
   GdkWindowType window_type;
+
+  int running;
+  s_thread_t *th_id;
+  s_window_t *xynth_window;
 };
 
 typedef struct {
@@ -153,6 +164,8 @@
   int manager_fd;
   int manager_tag;
   int manager_blocked;
+
+  s_window_t *xynth_root;
 };
 
 struct _GdkVisualClass
@@ -402,10 +415,8 @@
 
 guint32    gdk_fb_get_time                 (void);
 
-void       gdk_shadow_fb_update            (gint                 minx,
-					    gint                 miny,
-					    gint                 maxx,
-					    gint                 maxy);
+void gdk_shadow_fb_update (GdkDrawable *drawable, gint minx, gint miny, gint maxx, gint maxy);
+
 void       gdk_shadow_fb_init              (void);
 void       gdk_shadow_fb_stop_updates      (void);
 void       gdk_fb_recompute_all            (void);
@@ -429,8 +440,6 @@
 extern GdkDisplay *_gdk_display;
 extern GdkScreen *_gdk_screen;
 
-extern volatile gboolean _gdk_fb_is_active_vt;
-
 GdkEvent *gdk_event_make(GdkWindow *window,
 			 GdkEventType type,
 			 gboolean append_to_queue);
@@ -469,4 +478,7 @@
 void _gdk_events_init (void);
 void _gdk_input_init (void);
 
+void gdk_s_handler_mouse_ (s_event_t *event);
+void gdk_fb_handle_key (guint hw_keycode, guint keyval, guint modifier_state, guint8 group, gchar *string, gint string_length, gboolean key_up);
+
 #endif /* __GDK_PRIVATE_FB_H__ */
diff -Naur gtk+-2.4.14/gdk/linux-fb/gdkrender-fb.c gtk+-2.4.14-xynth/gdk/linux-fb/gdkrender-fb.c
--- gtk+-2.4.14/gdk/linux-fb/gdkrender-fb.c	2004-03-06 05:37:04.000000000 +0200
+++ gtk+-2.4.14-xynth/gdk/linux-fb/gdkrender-fb.c	2006-12-12 12:50:26.000000000 +0200
@@ -1,3 +1,9 @@
+/*
+ * Gtk-Xynth port is based on linux-fb port
+ * Xynth Team
+ * http://www.xynth.org
+ */
+
 #include <config.h>
 #include "gdkprivate-fb.h"
 #include <string.h>
@@ -235,9 +241,6 @@
   guint rowstride = private->rowstride;
   guchar *ptr;
 
-  if (!_gdk_fb_is_active_vt)
-    return;
-
   g_assert (private->depth == GDK_GC_FBDATA (gc)->depth);
   
   ptr = mem + (y*rowstride) + (x >> 3);
@@ -259,9 +262,6 @@
   guchar *mem = private->mem;
   guint rowstride = private->rowstride;
 
-  if (!_gdk_fb_is_active_vt)
-    return;
-
   g_assert (private->depth == GDK_GC_FBDATA (gc)->depth);
 
   mem[x + y*rowstride] = pixel;
@@ -279,9 +279,6 @@
   guint rowstride = private->rowstride;
   guint16 *ptr;
 
-  if (!_gdk_fb_is_active_vt)
-    return;
-
   g_assert (private->depth == GDK_GC_FBDATA (gc)->depth);
   
   ptr = (guint16 *)&mem[x*2 + y*rowstride];
@@ -300,9 +297,6 @@
   guint rowstride = private->rowstride;
   guchar *smem;
   
-  if (!_gdk_fb_is_active_vt)
-    return;
-
   g_assert (private->depth == GDK_GC_FBDATA (gc)->depth);
   
   smem = &mem[x*3 + y*rowstride];
@@ -323,9 +317,6 @@
   guint rowstride = private->rowstride;
   guint32 *smem;
 
-  if (!_gdk_fb_is_active_vt)
-    return;
-
   g_assert (private->depth == GDK_GC_FBDATA (gc)->depth);
   
   smem = (guint32 *)&mem[x*4 + y*rowstride];
@@ -358,9 +349,6 @@
   gboolean solid_stipple;
   GdkFunction func;
 
-  if (!_gdk_fb_is_active_vt)
-    return;
-
   private = GDK_DRAWABLE_FBDATA (drawable);
   gc_private = GDK_GC_FBDATA (gc);
 
@@ -519,9 +507,6 @@
   guint rowstride;
   gint left, right, y;
 
-  if (!_gdk_fb_is_active_vt)
-    return;
-
   private = GDK_DRAWABLE_FBDATA (drawable);
   gc_private = GDK_GC_FBDATA (gc);
 
@@ -588,9 +573,6 @@
   guchar *mem, *ptr;
   guint rowstride;
 
-  if (!_gdk_fb_is_active_vt)
-    return;
-
   private = GDK_DRAWABLE_FBDATA (drawable);
   gc_private = GDK_GC_FBDATA (gc);
 
@@ -622,9 +604,6 @@
   int n;
   int i;
 
-  if (!_gdk_fb_is_active_vt)
-    return;
-
   private = GDK_DRAWABLE_FBDATA (drawable);
   gc_private = GDK_GC_FBDATA (gc);
 
@@ -658,9 +637,6 @@
   guchar redval, greenval, blueval;
   guchar *firstline, *ptr_end;
 
-  if (!_gdk_fb_is_active_vt)
-    return;
-
   private = GDK_DRAWABLE_FBDATA (drawable);
   gc_private = GDK_GC_FBDATA (gc);
 
@@ -705,9 +681,6 @@
   int n;
   int i;
 
-  if (!_gdk_fb_is_active_vt)
-    return;
-
   private = GDK_DRAWABLE_FBDATA (drawable);
   gc_private = GDK_GC_FBDATA (gc);
 
@@ -915,9 +888,6 @@
   int linelen = (end_x - start_x)*(depth>>3);
   gint cur_y;
 
-  if (!_gdk_fb_is_active_vt)
-    return;
-
   if (draw_direction < 0)
     {
       int tmp;
@@ -963,9 +933,6 @@
   GdkColor fg;
   gint fg_r, fg_g, fg_b;
   
-  if (!_gdk_fb_is_active_vt)
-    return;
-
   gc_private = GDK_GC_FBDATA (gc);
 
   fg = GDK_GC_FBDATA (gc)->values.foreground;
@@ -1047,9 +1014,6 @@
   GdkSpan *spans;
   int i;
 
-  if (!_gdk_fb_is_active_vt)
-    return;
-
   private = GDK_DRAWABLE_FBDATA (drawable);
 
   spans = g_new (GdkSpan, rect->height);
@@ -1079,9 +1043,6 @@
   guint32 pixel;
   gint height;
   
-  if (!_gdk_fb_is_active_vt)
-    return;
-
   private = GDK_DRAWABLE_FBDATA (drawable);
   gc_private = GDK_GC_FBDATA (gc);
 
@@ -1128,9 +1089,6 @@
   guint32 pixel;
   gint height;
   
-  if (!_gdk_fb_is_active_vt)
-    return;
-
   private = GDK_DRAWABLE_FBDATA (drawable);
   gc_private = GDK_GC_FBDATA (gc);
 
@@ -1255,269 +1213,116 @@
     }
 }
 
-#ifdef ENABLE_SHADOW_FB
-static void
-gdk_shadow_fb_copy_rect_0 (gint x, gint y, gint width, gint height)
-{
-  guchar *dst, *src;
-  gint depth;
-
-  if (!_gdk_fb_is_active_vt)
-    return;
-
-  depth = gdk_display->modeinfo.bits_per_pixel / 8;
 
-  dst = gdk_display->fb_mmap + x * depth + gdk_display->sinfo.line_length * y;
-  src = gdk_display->fb_mem + x * depth + gdk_display->fb_stride * y;
-
-  width = width*depth;
-  while (height>0)
-    {
-      memcpy (dst, src, width);
-      dst += gdk_display->sinfo.line_length;
-      src += gdk_display->fb_stride;
-      height--;
-    }
-}
-
-static void
-gdk_shadow_fb_copy_rect_90 (gint x, gint y, gint width, gint height)
+void gdk_shadow_fb_stop_updates (void)
 {
-  guchar *dst, *src, *pdst;
-  gint depth;
-  gint w;
-  gint i;
-
-  if (!_gdk_fb_is_active_vt)
-    return;
-
-  depth = gdk_display->modeinfo.bits_per_pixel / 8;
-
-  src = gdk_display->fb_mem + x * depth + gdk_display->fb_stride * y;
-  dst = gdk_display->fb_mmap + y * depth + gdk_display->sinfo.line_length * (gdk_display->fb_width - x - 1);
-
-  while (height>0)
-    {
-      w = width;
-      pdst = dst;
-      while (w>0) {
-	for (i = 0; i < depth; i++)
-	  *pdst++ = *src++;
-	pdst -= gdk_display->sinfo.line_length + depth;
-	w--;
-      }
-      dst += depth;
-      src += gdk_display->fb_stride - width * depth;
-      height--;
-    }
 }
 
-static void
-gdk_shadow_fb_copy_rect_180 (gint x, gint y, gint width, gint height)
+int gdk_s_rect_intersect (s_rect_t *r1, s_rect_t *r2, s_rect_t *r)
 {
-  guchar *dst, *src, *pdst;
-  gint depth;
-  gint w;
-  gint i;
-
-  if (!_gdk_fb_is_active_vt)
-    return;
-
-  depth = gdk_display->modeinfo.bits_per_pixel / 8;
-
-  src = gdk_display->fb_mem + x * depth + gdk_display->fb_stride * y;
-  dst = gdk_display->fb_mmap + (gdk_display->fb_width - x - 1) * depth + gdk_display->sinfo.line_length * (gdk_display->fb_height - y - 1) ;
+	int x11 = r1->x;
+	int x12 = r1->x + r1->w - 1;
+	int y11 = r1->y;
+	int y13 = r1->y + r1->h - 1;
+	int x21 = r2->x;
+	int x22 = r2->x + r2->w - 1;
+	int y21 = r2->y;
+	int y23 = r2->y + r2->h - 1;
+	int x31, x32;
+	int y31, y33;
+
+	x31 = ((x11 > x21) ? x11 : x21);
+	x32 = ((x12 < x22) ? x12 : x22);
+
+	y31 = ((y11 > y21) ? y11 : y21);
+	y33 = ((y13 < y23) ? y13 : y23);
+
+	r->x = x31;
+	r->y = y31;
+	r->w = x32 - x31 + 1;
+	r->h = y33 - y31 + 1;
+
+	if ((r->w > 0) &&
+	    (r->h > 0) &&
+	    (r->x >= r1->x) &&
+	    (r->y >= r1->y) &&
+	    ((r->x + r->w) <= (r1->x + r1->w)) &&
+	    ((r->y + r->h) <= (r1->y + r1->h))) {
+		/* r is in r1 */
+		return 0;
+	}
 
-  while (height>0)
-    {
-      w = width;
-      pdst = dst;
-      while (w>0) {
-	for (i = 0; i < depth; i++)
-	  *pdst++ = *src++;
-	pdst -= 2 * depth;
-	w--;
-      }
-      dst -= gdk_display->sinfo.line_length;
-      src += gdk_display->fb_stride - width * depth;
-      height--;
-    }
+	return -1;
 }
 
-static void
-gdk_shadow_fb_copy_rect_270 (gint x, gint y, gint width, gint height)
+static void gdk_shadow_fb_copy_rect_0_ (s_window_t *window, gint x, gint y, gint width, gint height)
 {
-  guchar *dst, *src, *pdst;
-  gint depth;
-  gint w;
-  gint i;
-
-  if (!_gdk_fb_is_active_vt)
-    return;
-
-  depth = gdk_display->modeinfo.bits_per_pixel / 8;
-
-  src = gdk_display->fb_mem + x * depth + gdk_display->fb_stride * y;
-  dst = gdk_display->fb_mmap + (gdk_display->fb_height - y - 1) * depth + gdk_display->sinfo.line_length * x;
-
-  while (height>0)
-    {
-      w = width;
-      pdst = dst;
-      while (w>0) {
-	for (i = 0; i < depth; i++)
-	  *pdst++ = *src++;
-	pdst += gdk_display->sinfo.line_length - depth;
-	w--;
-      }
-      dst -= depth;
-      src += gdk_display->fb_stride - width * depth;
-      height--;
-    }
+        s_putboxpart(window->surface, x - GDK_DRAWABLE_IMPL_FBDATA((GdkWindow *) window->data)->abs_x,
+                                      y - GDK_DRAWABLE_IMPL_FBDATA((GdkWindow *) window->data)->abs_y,
+                                      width, height, window->surface->width, window->surface->height, gdk_display->fb_mem, x, y);
 }
 
-static void (*shadow_copy_rect[4]) (gint x, gint y, gint width, gint height);
-
-volatile gint refresh_queued = 0;
-volatile gint refresh_x1, refresh_y1;
-volatile gint refresh_x2, refresh_y2;
-
-static void
-gdk_shadow_fb_refresh (int signum)
+int gdk_s_window_child_find (s_window_t *parent, s_window_t *window, int x, int y, int w, int h)
 {
-  gint minx, miny, maxx, maxy;
+        int p = 0;
+        s_rect_t r;
+        s_rect_t i;
+        s_window_t *win;
 
-  if (!refresh_queued)
-    {
-      struct itimerval timeout;
-      /* Stop the timer */ 
-      timeout.it_value.tv_sec = 0;
-      timeout.it_value.tv_usec = 0;
-      timeout.it_interval.tv_sec = 0;
-      timeout.it_interval.tv_usec = 0;
-      setitimer (ITIMER_REAL, &timeout, NULL);
-      return;
-    }
- 
-  
-  minx = refresh_x1;
-  miny = refresh_y1;
-  maxx = refresh_x2;
-  maxy = refresh_y2;
-  refresh_queued = 0;
-
-  /* clip x */
-  if (minx < 0) {
-    minx = 0;
-    maxx = MAX (maxx, 0);
-  }
-  if (maxx >= gdk_display->fb_width) {
-    maxx = gdk_display->fb_width-1;
-    minx = MIN (minx, maxx);
-  }
-  /* clip y */
-  if (miny < 0) {
-    miny = 0;
-    maxy = MAX (maxy, 0);
-  }
-  if (maxy >= gdk_display->fb_height) {
-    maxy = gdk_display->fb_height-1;
-    miny = MIN (miny, maxy);
-  }
-  
-  (*shadow_copy_rect[_gdk_fb_screen_angle]) (minx, miny, maxx - minx + 1, maxy - miny + 1);
-}
+        r.x = x;
+        r.y = y;
+        r.w = w;
+        r.h = h;
 
-void
-gdk_shadow_fb_stop_updates (void)
-{
-  struct itimerval timeout;
-
-  refresh_queued = 0;
-
-  /* Stop the timer */ 
-  timeout.it_value.tv_sec = 0;
-  timeout.it_value.tv_usec = 0;
-  timeout.it_interval.tv_sec = 0;
-  timeout.it_interval.tv_usec = 0;
-  setitimer (ITIMER_REAL, &timeout, NULL);
-
-  refresh_queued = 0;
-}
-
-void
-gdk_shadow_fb_init (void)
-{
-  struct sigaction action;
-
-  action.sa_handler = gdk_shadow_fb_refresh;
-  sigemptyset (&action.sa_mask);
-  action.sa_flags = 0;
-  
-  sigaction (SIGALRM, &action, NULL);
+        if (!gdk_s_rect_intersect(parent->surface->buf, &r, &i)) {
+		gdk_shadow_fb_copy_rect_0_(parent, i.x, i.y, i.w, i.h);
+	}
+		
+	s_thread_mutex_lock(window->childs->mut);
+	while (!s_list_eol(window->childs->list, p)) {
+		win = (s_window_t *) s_list_get(window->childs->list, p);
+		if (!gdk_s_rect_intersect(win->surface->buf, &r, &i)) {
+			gdk_shadow_fb_copy_rect_0_(win, i.x, i.y, i.w, i.h);
+		}
+		gdk_s_window_child_find(parent, win, x, y, w, h);
+		p++;
+	}
+	s_thread_mutex_unlock(window->childs->mut);
 
-  shadow_copy_rect[GDK_FB_0_DEGREES] = gdk_shadow_fb_copy_rect_0;
-  shadow_copy_rect[GDK_FB_90_DEGREES] = gdk_shadow_fb_copy_rect_90;
-  shadow_copy_rect[GDK_FB_180_DEGREES] = gdk_shadow_fb_copy_rect_180;
-  shadow_copy_rect[GDK_FB_270_DEGREES] = gdk_shadow_fb_copy_rect_270;
+	return 0;
 }
 
-/* maxx and maxy are included */
-void
-gdk_shadow_fb_update (gint minx, gint miny, gint maxx, gint maxy)
+void gdk_shadow_fb_update (GdkDrawable *drawable, gint minx, gint miny, gint maxx, gint maxy)
 {
-  struct itimerval timeout;
-
-  if (gdk_display->manager_blocked)
-    return;
-  
-  g_assert (minx <= maxx);
-  g_assert (miny <= maxy);
+	if (gdk_display->manager_blocked) {
+		return;
+	}
 
-  if (refresh_queued)
-    {
-      refresh_x1 = MIN (refresh_x1, minx);
-      refresh_y1 = MIN (refresh_y1, miny);
-      refresh_x2 = MAX (refresh_x2, maxx);
-      refresh_y2 = MAX (refresh_y2, maxy);
-      refresh_queued = 1;
-    }
-  else
-    {
-      refresh_x1 = minx;
-      refresh_y1 = miny;
-      refresh_x2 = maxx;
-      refresh_y2 = maxy;
-      refresh_queued = 1;
+	g_assert(minx <= maxx);
+	g_assert(miny <= maxy);
 
-      getitimer (ITIMER_REAL, &timeout);
-      if (timeout.it_value.tv_usec == 0)
-	{
-	  timeout.it_value.tv_sec = 0;
-	  timeout.it_value.tv_usec = 20000; /* 20 ms => 50 fps */
-	  timeout.it_interval.tv_sec = 0;
-	  timeout.it_interval.tv_usec = 20000; /* 20 ms => 50 fps */
-	  setitimer (ITIMER_REAL, &timeout, NULL);
+	/* clip x */
+	if (minx < 0) {
+		minx = 0;
+		maxx = MAX (maxx, 0);
+	}
+        if (maxx >= gdk_display->fb_width) {
+		maxx = gdk_display->fb_width-1;
+		minx = MIN (minx, maxx);
+	}
+	/* clip y */
+	if (miny < 0) {
+		miny = 0;
+		maxy = MAX (maxy, 0);
+	}
+	if (maxy >= gdk_display->fb_height) {
+		maxy = gdk_display->fb_height-1;
+		miny = MIN (miny, maxy);
 	}
-    }
-  
-}
-#else
 
-void
-gdk_shadow_fb_stop_updates (void)
-{
+	gdk_s_window_child_find(gdk_display->xynth_root, gdk_display->xynth_root, minx, miny, maxx - minx + 1, maxy - miny + 1);
 }
 
-void
-gdk_shadow_fb_update (gint minx, gint miny, gint maxx, gint maxy)
+void gdk_shadow_fb_init (void)
 {
 }
-
-void
-gdk_shadow_fb_init (void)
-{
-}
-
-#endif
-
diff -Naur gtk+-2.4.14/gdk/linux-fb/gdkwindow-fb.c gtk+-2.4.14-xynth/gdk/linux-fb/gdkwindow-fb.c
--- gtk+-2.4.14/gdk/linux-fb/gdkwindow-fb.c	2004-07-28 19:06:54.000000000 +0300
+++ gtk+-2.4.14-xynth/gdk/linux-fb/gdkwindow-fb.c	2006-12-12 12:53:59.000000000 +0200
@@ -23,6 +23,12 @@
  * files for a list of changes.  These files are distributed with
  * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
  */
+ 
+/*
+ * Gtk-Xynth port is based on linux-fb port
+ * Xynth Team
+ * http://www.xynth.org
+ */
 
 #include <config.h>
 #include "gdk.h"
@@ -31,6 +37,7 @@
 #include "gdkinputprivate.h"
 #include "gdkprivate-fb.h"
 #include "gdkinternals.h"
+#include "gdkkeysyms.h"
 
 #include <limits.h>
 
@@ -42,6 +49,7 @@
 static void recompute_drawable (GdkDrawable *drawable);
 static void gdk_fb_window_raise (GdkWindow *window);
 static GdkRegion* gdk_window_fb_get_visible_region (GdkDrawable *drawable);
+static void gdk_fb_change_focus (GdkWindow *new_focus_window);
 
 typedef struct
 {
@@ -161,113 +169,242 @@
   gdk_window_set_cursor (_gdk_parent_root, cursor);
 }
 
-GdkWindow*
-gdk_window_new (GdkWindow     *parent,
-		GdkWindowAttr *attributes,
-		gint           attributes_mask)
+void gdk_client_atevent (s_window_t *window, s_event_t *event)
 {
-  GdkWindow *window;
+GdkWindow *gwindow = window->data;
+GdkWindowObject *private = (GdkWindowObject *) gwindow;
+
+	if (event->type & EXPOSE_EVENT) {
+		if ((((GdkWindowObject *) window->data)->x != window->surface->buf->x) ||
+		    (((GdkWindowObject *) window->data)->y != window->surface->buf->y) ||
+		    (GDK_DRAWABLE_IMPL_FBDATA((GdkWindowObject *) window->data)->width != window->surface->buf->w) ||
+		    (GDK_DRAWABLE_IMPL_FBDATA((GdkWindowObject *) window->data)->height != window->surface->buf->h)) {
+			gdk_window_move_resize((GdkWindow *) window->data,
+			                       window->surface->buf->x, window->surface->buf->y,
+			                       window->surface->buf->w, window->surface->buf->h);
+		}
+	/* Change focus event coming from xynth */
+	if ((event->type & FOCUS_EVENT) && (GDK_WINDOW_TYPE(gwindow)==GDK_WINDOW_TOPLEVEL)){
+	if (window->pri == 0)
+	{
+	GdkEventFocus *gevent;
+	gevent = (GdkEventFocus *)gdk_event_make (gwindow, GDK_FOCUS_CHANGE, TRUE);
+	gevent->in = TRUE;
+	if (gdk_fb_focused_window)
+	gdk_window_unref (gdk_fb_focused_window);
+  gdk_fb_focused_window = gdk_window_ref (gwindow);
+	private->state = GDK_WINDOW_STATE_WITHDRAWN;
+	gdk_window_show(gwindow);
+	}
+	}
+	} 
+	else if (event->type & MOUSE_EVENT) {
+		gdk_s_handler_mouse_(event);
+	} else if (event->type & KEYBD_PRESSED) {
+		if (event->keybd->ascii == 8) {
+			gdk_fb_handle_key (GDK_BackSpace, GDK_BackSpace, 0, 0, g_strdup("\10"), 1, FALSE);
+		} else if (event->keybd->ascii == 9) {
+			gdk_fb_handle_key (GDK_Tab, GDK_Tab, 0, 0, g_strdup("\t"), 1, FALSE);
+		} else if (event->keybd->ascii == 13) {
+			gdk_fb_handle_key (GDK_Return, GDK_Return, 0, 0, g_strdup("\r"), 1, FALSE);
+		} else {
+			gdk_fb_handle_key (0, event->keybd->ascii, 0, 0, NULL, 0, FALSE);
+		}
+	}
+}
+
+void gdk_client_atexit (s_window_t *window)
+{
+	GList *l;
   GdkWindowObject *private;
-  GdkWindowObject *parent_private;
-  GdkVisual *visual;
-  GdkWindowFBData *impl;
+	GdkEvent *event;
+	GdkWindow *destroy_window = (GdkWindow *) window->data;
 
-  int x, y, depth;
-  
-  g_return_val_if_fail (attributes != NULL, NULL);
-  
-  if (!parent ||
-      (attributes->window_type != GDK_WINDOW_CHILD &&
-       attributes->window_type != GDK_WINDOW_TEMP))
-    parent = _gdk_parent_root;
-  
-  parent_private = (GdkWindowObject*) parent;
-  
-  window = (GdkWindow *)g_object_new (GDK_TYPE_WINDOW, NULL);
-  private = (GdkWindowObject *)window;
+  private = (GdkWindowObject *) _gdk_parent_root;
+	
+	GDK_DRAWABLE_IMPL_FBDATA(destroy_window)->running = 0;
+	
+	
+	if (GDK_DRAWABLE_IMPL_FBDATA(destroy_window)->window_type == GDK_WINDOW_TEMP) {
+		gdk_window_hide(destroy_window);
+	} else {
+		for (l = private->children; l; l = l->next)
+	 	{
+	   if ((GDK_DRAWABLE_IMPL_FBDATA(l->data)->window_type == GDK_WINDOW_TEMP) &&
+		 (GDK_DRAWABLE_IMPL_FBDATA(l->data)->running != 0) &&
+		 (((GdkWindowObject *)(l->data))->state != GDK_WINDOW_STATE_WITHDRAWN))
+			{
+				gdk_window_hide(l->data);
+			}
+		}
+		event = gdk_event_new(GDK_DELETE);
+		event->any.type = GDK_DELETE;
+		event->any.window = g_object_ref(destroy_window);
+		event->any.send_event = TRUE;
+		_gdk_event_queue_append(gdk_display_get_default(), event);
+	}
+	
+}
 
-  private->parent = parent_private;
+static const gchar * get_default_title (void)
+{
+	const char *title;
+	
+	title = g_get_application_name();
+	if (!title) {
+		title = g_get_prgname ();
+	}
+	return title;
+}
 
-  private->accept_focus = TRUE;
+GdkWindow * gdk_window_new (GdkWindow *parent, GdkWindowAttr *attributes, gint attributes_mask)
+{
+	GdkWindow *window;
+	GdkWindowObject *private;
+	GdkWindowObject *parent_private;
+	GdkVisual *visual;
+	GdkWindowFBData *impl;
+        
+        const gchar *title;
+	int x, y, depth;
 
-  if (attributes_mask & GDK_WA_X)
-    x = attributes->x;
-  else
-    x = 0;
+	g_return_val_if_fail(attributes != NULL, NULL);
 
-  if (attributes_mask & GDK_WA_Y)
-    y = attributes->y;
-  else
-    y = 0;
+	if (!parent || (attributes->window_type != GDK_WINDOW_CHILD &&
+	                attributes->window_type != GDK_WINDOW_TEMP)) {
+		parent = _gdk_parent_root;
+	}
+        parent_private = (GdkWindowObject *) parent;
 
-  gdk_window_set_events (window, attributes->event_mask);
+	window = (GdkWindow *) g_object_new(GDK_TYPE_WINDOW, NULL);
+	private = (GdkWindowObject *) window;
 
-  if (attributes_mask & GDK_WA_VISUAL)
-    visual = attributes->visual;
-  else
-    visual = gdk_visual_get_system ();
+	private->parent = parent_private;
+	private->accept_focus = TRUE;
 
-  impl = (GdkWindowFBData *)private->impl;
-  impl->drawable_data.wrapper = window;
-  private->x = x;
-  private->y = y;
-  impl->drawable_data.width = (attributes->width > 1) ? (attributes->width) : (1);
-  impl->drawable_data.height = (attributes->height > 1) ? (attributes->height) : (1);
-  private->window_type = impl->drawable_data.window_type = attributes->window_type;
-  impl->drawable_data.mem = gdk_display->fb_mem;
-  impl->drawable_data.rowstride = gdk_display->fb_stride;
-  gdk_window_move_resize (window, x, y,
-			  impl->drawable_data.width, impl->drawable_data.height);
+	if (attributes_mask & GDK_WA_X) {
+		x = attributes->x;
+	} else {
+		x = 0;
+	}
 
-  if (attributes->wclass == GDK_INPUT_OUTPUT)
-    {
-      depth = visual->depth;
+	if (attributes_mask & GDK_WA_Y) {
+		y = attributes->y;
+	} else {
+		y = 0;
+	}
 
-      private->input_only = FALSE;
-      private->depth = impl->drawable_data.depth;
-      
-      if ((attributes_mask & GDK_WA_COLORMAP) &&
-	  attributes->colormap)
-	impl->drawable_data.colormap = attributes->colormap;
-      else
-	impl->drawable_data.colormap = gdk_colormap_get_system ();
-      
-      switch (impl->drawable_data.window_type)
-	{
-	case GDK_WINDOW_TOPLEVEL:
-	case GDK_WINDOW_CHILD:
-	case GDK_WINDOW_DIALOG:
-	case GDK_WINDOW_TEMP:
-	default:
-	  break;
-	  
-	case GDK_WINDOW_ROOT:
-	  if (_gdk_parent_root)
-	    g_error ("cannot make windows of type GDK_WINDOW_ROOT");
-	  break;
-	case GDK_DRAWABLE_PIXMAP:
-	  g_error ("cannot make windows of type GDK_DRAWABLE_PIXMAP (use gdk_pixmap_new)");
-	  break;
+	gdk_window_set_events (window, attributes->event_mask);
+
+	if (attributes_mask & GDK_WA_VISUAL) {
+		visual = attributes->visual;
+	} else {
+		visual = gdk_visual_get_system();
 	}
-    }
-  else
-    {
-      depth = 0;
-      private->input_only = TRUE;
-      impl->drawable_data.colormap = NULL;
-    }
+	
+        impl = (GdkWindowFBData *) private->impl;
+        impl->drawable_data.wrapper = window;
+        private->x = x;
+        private->y = y;
+        impl->drawable_data.width = (attributes->width > 1) ? (attributes->width) : (1);
+        impl->drawable_data.height = (attributes->height > 1) ? (attributes->height) : (1);
+        private->window_type = impl->drawable_data.window_type = attributes->window_type;
+        impl->drawable_data.mem = gdk_display->fb_mem;
+        impl->drawable_data.rowstride = gdk_display->fb_stride;
+        gdk_window_move_resize(window, x, y, impl->drawable_data.width, impl->drawable_data.height);
+
+        switch (impl->drawable_data.window_type) {
+                case GDK_WINDOW_ROOT:
+                	{
+				GDK_DRAWABLE_IMPL_FBDATA(window)->xynth_window = gdk_display->xynth_root;
+				gdk_display->xynth_root->data = window;
+			}
+			break;
+		default:
+			break;
+	}
+	
+        if (attributes->wclass == GDK_INPUT_OUTPUT) {
+		depth = visual->depth;
+
+		private->input_only = FALSE;
+		private->depth = impl->drawable_data.depth;
+
+		if ((attributes_mask & GDK_WA_COLORMAP) && attributes->colormap) {
+			impl->drawable_data.colormap = attributes->colormap;
+		} else {
+			impl->drawable_data.colormap = gdk_colormap_get_system();
+		}
 
-  if (impl->drawable_data.colormap)
-    gdk_colormap_ref (impl->drawable_data.colormap);
-  
-  gdk_window_set_cursor (window, ((attributes_mask & GDK_WA_CURSOR) ?
-				  (attributes->cursor) :
-				  NULL));
+		switch (impl->drawable_data.window_type) {
+		case GDK_WINDOW_TOPLEVEL:
+				{
+					s_window_t *window_tl;
+					s_window_init(&window_tl);
+					s_window_new(window_tl, WINDOW_CHILD, gdk_display->xynth_root);
+					if (attributes->title != NULL) {
+						title = attributes->title;
+					} else {
+						title = get_default_title();
+					}
+					s_window_atevent(window_tl, gdk_client_atevent);
+					s_window_atexit(window_tl, gdk_client_atexit);
+					window_tl->data = window;
+	        s_window_main(window_tl);
+          impl->drawable_data.running = 1;
+          impl->drawable_data.th_id = window_tl->tid;
+					impl->drawable_data.xynth_window = window_tl;
+          gdk_window_set_title (window, title);
+				}
+				break;
+			case GDK_WINDOW_CHILD:
+			case GDK_WINDOW_DIALOG:
+			case GDK_WINDOW_TEMP:
+			 if ( GDK_WINDOW_TYPE (parent) == GDK_WINDOW_ROOT )
+				{
+				s_window_t *window_tmp;
+				s_window_init(&window_tmp);
+				//s_window_new(window_tmp, WINDOW_TEMP | WINDOW_NOFORM, gdk_display->xynth_root);
+				s_window_new(window_tmp, WINDOW_CHILD | WINDOW_NOFORM , gdk_display->xynth_root);
+				s_window_atevent(window_tmp, gdk_client_atevent);
+				s_window_atexit(window_tmp, gdk_client_atexit);
+				window_tmp->data = window;
+			
+				GDK_DRAWABLE_IMPL_FBDATA(window)->running = 1;
+				GDK_DRAWABLE_IMPL_FBDATA(window)->th_id = window_tmp->tid;
+				GDK_DRAWABLE_IMPL_FBDATA(window)->xynth_window = window_tmp;
+				GDK_DRAWABLE_IMPL_FBDATA(window)->mem = window_tmp->surface->vbuf;
+				
+				s_window_main(window_tmp);	
+			  }
+			default:
+				break;
+			case GDK_WINDOW_ROOT:
+				if (_gdk_parent_root) {
+					g_error ("cannot make windows of type GDK_WINDOW_ROOT");
+				}
+				break;
+			case GDK_DRAWABLE_PIXMAP:
+				g_error ("cannot make windows of type GDK_DRAWABLE_PIXMAP (use gdk_pixmap_new)");
+				break;
+		}
+	} else {
+		depth = 0;
+		private->input_only = TRUE;
+		impl->drawable_data.colormap = NULL;
+	}
+	
+        if (impl->drawable_data.colormap) {
+		gdk_colormap_ref(impl->drawable_data.colormap);
+	}
 
-  if (parent_private)
-    parent_private->children = g_list_prepend (parent_private->children, window);
-  
-  return window;
+	gdk_window_set_cursor(window, ((attributes_mask & GDK_WA_CURSOR) ? (attributes->cursor) : NULL));
+
+	if (parent_private) {
+		parent_private->children = g_list_prepend (parent_private->children, window);
+	}
+	
+        return window;
 }
 
 /* This function is called when the XWindow is really gone.  */
@@ -289,13 +426,19 @@
   r.height = GDK_DRAWABLE_IMPL_FBDATA (window)->height;
   /* Clear the root window, as it might be visible under
      the destroyed window */
-  gdk_window_clear_area (_gdk_parent_root,
-			 r.x,
-			 r.y,
-			 r.width,
-			 r.height);
+  gdk_window_clear_area (_gdk_parent_root, r.x, r.y, r.width, r.height);
   /* Invalidate the rect */
   gdk_window_invalidate_rect ((GdkWindow *)private->parent, &r, TRUE);
+
+	if ((GDK_DRAWABLE_IMPL_FBDATA(window)->window_type == GDK_WINDOW_TOPLEVEL)
+	|| (GDK_DRAWABLE_IMPL_FBDATA(window)->window_type ==GDK_WINDOW_TEMP))
+	{
+		if (GDK_DRAWABLE_IMPL_FBDATA(window)->running) {
+			s_window_quit(GDK_DRAWABLE_IMPL_FBDATA(window)->xynth_window);
+			s_thread_join(GDK_DRAWABLE_IMPL_FBDATA(window)->th_id, NULL);
+		}
+	}
+
 }
 
 static gboolean
@@ -466,8 +609,6 @@
   gdk_window_process_all_updates ();
 }
 
-
-/* Focus follows pointer */
 static GdkWindow *
 gdk_fb_window_find_toplevel (GdkWindow *window)
 {
@@ -478,23 +619,10 @@
 	return (GdkWindow *)priv;
       priv = priv->parent;
     }
- 
-  return _gdk_parent_root;
-}
 
-GdkWindow *
-gdk_fb_window_find_focus (void)
-{
-  if (_gdk_fb_keyboard_grab_window)
-    return _gdk_fb_keyboard_grab_window;
-  
-  if (!gdk_fb_focused_window)
-    gdk_fb_focused_window = gdk_window_ref (_gdk_parent_root);
-  
-  return gdk_fb_focused_window;
+  return _gdk_parent_root;
 }
 
-
 static void
 gdk_fb_change_focus (GdkWindow *new_focus_window)
 {
@@ -503,11 +631,11 @@
   GdkWindow *event_win;
 
   /* No focus changes while the pointer is grabbed */
-  if (_gdk_fb_pointer_grab_window)
+ if (_gdk_fb_pointer_grab_window)
     return;
-  
+
   old_win = gdk_fb_focused_window;
-  new_win = gdk_fb_window_find_toplevel (new_focus_window);
+  new_win = gdk_fb_window_find_toplevel(new_focus_window);
 
   if (old_win != new_win)
     {
@@ -526,13 +654,27 @@
 	  event = (GdkEventFocus *)gdk_event_make (event_win, GDK_FOCUS_CHANGE, TRUE);
 	  event->in = TRUE;
 	}
-      
+
       if (gdk_fb_focused_window)
 	gdk_window_unref (gdk_fb_focused_window);
       gdk_fb_focused_window = gdk_window_ref (new_win);
     }
 }
 
+GdkWindow *
+gdk_fb_window_find_focus (void)
+{
+  if (_gdk_fb_keyboard_grab_window)
+    return _gdk_fb_keyboard_grab_window;
+  
+  if (!gdk_fb_focused_window)
+    gdk_fb_focused_window = gdk_window_ref (_gdk_parent_root);
+  
+  return gdk_fb_focused_window;
+}
+
+
+
 static GdkWindow *
 gdk_fb_find_common_ancestor (GdkWindow *win1,
 			     GdkWindow *win2)
@@ -779,8 +921,20 @@
 	  rect.width = GDK_DRAWABLE_IMPL_FBDATA (window)->lim_x - rect.x;
 	  rect.height = GDK_DRAWABLE_IMPL_FBDATA (window)->lim_y - rect.y;
 	  gdk_window_invalidate_rect (_gdk_parent_root, &rect, TRUE);
+
+		if ((GDK_DRAWABLE_IMPL_FBDATA(window)->window_type == GDK_WINDOW_TOPLEVEL) 
+		|| (GDK_DRAWABLE_IMPL_FBDATA(window)->window_type == GDK_WINDOW_TEMP)) {
+	  s_window_t *window_tmp = GDK_DRAWABLE_IMPL_FBDATA(window)->xynth_window;
+		s_window_set_coor(window_tmp, WINDOW_NOFORM, ((GdkWindowObject *) window)->x,
+			                                      ((GdkWindowObject *) window)->y,
+			                                      GDK_DRAWABLE_IMPL_FBDATA((GdkWindowObject *) window)->width,
+			                                      GDK_DRAWABLE_IMPL_FBDATA((GdkWindowObject *) window)->height);
+		
+		s_window_show(window_tmp);
+		}
+	
 	}
-    }
+	 }
 }
 
 void
@@ -853,6 +1007,12 @@
       
       if (do_hide)
 	gdk_fb_cursor_unhide ();
+
+		if ( GDK_DRAWABLE_IMPL_FBDATA(window)->window_type == GDK_WINDOW_TEMP) {
+			if(GDK_DRAWABLE_IMPL_FBDATA(window)->running) {
+				s_window_hide (GDK_DRAWABLE_IMPL_FBDATA(window)->xynth_window);
+			}
+		}
     }
 }
 
@@ -1074,7 +1234,7 @@
       private->y = y;
       GDK_DRAWABLE_IMPL_FBDATA (private)->width = width;
       GDK_DRAWABLE_IMPL_FBDATA (private)->height = height;
-
+      
       if (GDK_WINDOW_IS_MAPPED (private))
 	{
 	  recompute_drawable ((GdkDrawable *)window);
@@ -1124,8 +1284,8 @@
 		    }
 		  gdk_fb_drawing_context_finalize (&fbdc);
 		}
-	      gdk_shadow_fb_update (region->extents.x1, region->extents.y1, 
-				    region->extents.x2, region->extents.y2);
+
+	      gdk_shadow_fb_update(GDK_DRAWABLE_IMPL(window), region->extents.x1, region->extents.y1, region->extents.x2, region->extents.y2);
 	      
 	      gdk_region_union (new_region, old_region);
 	      gdk_region_subtract (new_region, region);
@@ -1401,10 +1561,12 @@
 {
 }
 
-void
-gdk_window_set_title (GdkWindow   *window,
-		      const gchar *title)
+void gdk_window_set_title (GdkWindow *window, const gchar *title)
 {
+	
+	s_window_t *win;
+   	win = GDK_DRAWABLE_IMPL_FBDATA(window)->xynth_window;
+     	s_window_set_title(win, (char *) title);
 }
 
 void          
@@ -1440,8 +1602,8 @@
 }
 
 void
-gdk_window_set_background (GdkWindow      *window,
-			   const GdkColor *color)
+gdk_window_set_background (GdkWindow *window,
+			   const GdkColor  *color)
 {
   GdkWindowObject *private = (GdkWindowObject *)window;
   
@@ -1525,16 +1687,14 @@
 			 gint      *height,
 			 gint      *depth)
 {
-  GdkWindowObject *private = (GdkWindowObject *)window;
+  GdkWindowObject *private = (GdkWindowObject *) window;
   
   g_return_if_fail (window == NULL || GDK_IS_WINDOW (window));
   
   if (!window)
     window = _gdk_parent_root;
   
-  if (!private->destroyed)
-    {
-
+   if (!GDK_WINDOW_DESTROYED(window)) {
       if (x)
 	*x = private->x;
       if (y)
@@ -2229,17 +2389,26 @@
 void
 gdk_window_set_keep_above (GdkWindow *window, gboolean setting)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
+	g_return_if_fail(GDK_IS_WINDOW(window));
 
-  g_warning ("gdk_window_set_keep_above() not implemented.\n");
+	if ((GDK_IS_WINDOW(window)) && (((GdkWindowObject *) window)->window_type == GDK_WINDOW_TOPLEVEL)) {
+		s_window_set_coor(GDK_DRAWABLE_IMPL_FBDATA((GdkWindowObject *) window)->xynth_window,
+		                  WINDOW_NOFORM,
+		                  ((GdkWindowObject *) window)->x,
+		                  ((GdkWindowObject *) window)->y,
+		                  GDK_DRAWABLE_IMPL_FBDATA((GdkWindowObject *) window)->width,
+		                  GDK_DRAWABLE_IMPL_FBDATA((GdkWindowObject *) window)->height);
+		return;
+	}
+			
+//	g_warning("gdk_window_set_keep_above() not implemented. (window_type = %d\n", ((GdkWindowObject *) window)->window_type);
 }
 
-void
-gdk_window_set_keep_below (GdkWindow *window, gboolean setting)
+void gdk_window_set_keep_below (GdkWindow *window, gboolean setting)
 {
-  g_return_if_fail (GDK_IS_WINDOW (window));
+	g_return_if_fail (GDK_IS_WINDOW (window));
 
-  g_warning ("gdk_window_set_keep_below() not implemented.\n");
+//	g_warning("gdk_window_set_keep_below() not implemented. (window_type = %d\n", ((GdkWindowObject *) window)->window_type);
 }
 
 void
@@ -2342,3 +2511,8 @@
 
   return (GdkWindow*) (anid);
 }
+
+void _gdk_windowing_window_destroy_foreign (GdkWindow *window)
+{
+}
+
diff -Naur gtk+-2.4.14/gtk/gtkwindow-decorate.c gtk+-2.4.14-xynth/gtk/gtkwindow-decorate.c
--- gtk+-2.4.14/gtk/gtkwindow-decorate.c	2004-03-06 05:38:37.000000000 +0200
+++ gtk+-2.4.14-xynth/gtk/gtkwindow-decorate.c	2006-12-12 13:00:51.000000000 +0200
@@ -28,7 +28,7 @@
 
 
 #ifdef GDK_WINDOWING_FB
-#define DECORATE_WINDOWS
+//#define DECORATE_WINDOWS
 #endif
 
 #ifdef DECORATE_WINDOWS
