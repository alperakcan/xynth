diff -Naur cairo-1.4.2/boilerplate/Makefile.am cairo-1.4.2-xynth/boilerplate/Makefile.am
--- cairo-1.4.2/boilerplate/Makefile.am	2007-03-20 08:49:29.000000000 +0200
+++ cairo-1.4.2-xynth/boilerplate/Makefile.am	2007-03-30 11:09:54.000000000 +0300
@@ -17,6 +17,10 @@
 libcairoboilerplate_la_SOURCES += cairo-test-directfb.c cairo-test-directfb.h
 endif
 
+if CAIRO_HAS_XYNTH_SURFACE
+libcairoboilerplate_la_SOURCES += cairo-test-xynth.c cairo-test-xynth.h
+endif
+
 if CAIRO_CAN_TEST_GLITZ_AGL_SURFACE
 libcairoboilerplate_la_LIBADD += $(GLITZ_AGL_LIBS)
 endif
diff -Naur cairo-1.4.2/boilerplate/cairo-boilerplate.c cairo-1.4.2-xynth/boilerplate/cairo-boilerplate.c
--- cairo-1.4.2/boilerplate/cairo-boilerplate.c	2007-03-19 22:08:03.000000000 +0200
+++ cairo-1.4.2-xynth/boilerplate/cairo-boilerplate.c	2007-03-30 11:11:04.000000000 +0300
@@ -1037,6 +1037,10 @@
 #include "cairo-test-directfb.h"
 #endif
 
+#if CAIRO_HAS_XYNTH_SURFACE
+#include "cairo-test-xynth.h"
+#endif
+
 #if CAIRO_HAS_PS_SURFACE
 #include "cairo-ps.h"
 
@@ -1368,6 +1372,7 @@
     /* I'm uncompromising about leaving the image backend as 0
      * for tolerance. There shouldn't ever be anything that is out of
      * our control here. */
+#if 0
     { "image", CAIRO_SURFACE_TYPE_IMAGE, CAIRO_CONTENT_COLOR_ALPHA, 0,
       create_image_surface, cairo_surface_write_to_png, NULL},
     { "image", CAIRO_SURFACE_TYPE_IMAGE, CAIRO_CONTENT_COLOR, 0,
@@ -1515,6 +1520,22 @@
       create_directfb_surface, cairo_surface_write_to_png,cleanup_directfb},
 #endif
 
+#if CAIRO_HAS_XYNTH_SURFACE
+    { "xynth", CAIRO_SURFACE_TYPE_XYNTH, CAIRO_CONTENT_COLOR, 0,
+      create_xynth_surface, cairo_surface_write_to_png, cleanup_xynth},
+    { "xynth", CAIRO_SURFACE_TYPE_XYNTH, CAIRO_CONTENT_COLOR_ALPHA, 0,
+      create_xynth_surface, cairo_surface_write_to_png, cleanup_xynth},
+#endif
+#else
+    { "image", CAIRO_SURFACE_TYPE_IMAGE, CAIRO_CONTENT_COLOR, 0,
+      create_image_surface, cairo_surface_write_to_png, NULL},
+    { "image", CAIRO_SURFACE_TYPE_IMAGE, CAIRO_CONTENT_COLOR_ALPHA, 0,
+      create_image_surface, cairo_surface_write_to_png, NULL},
+    { "xynth", CAIRO_SURFACE_TYPE_XYNTH, CAIRO_CONTENT_COLOR, 0,
+      create_xynth_surface, cairo_surface_write_to_png, cleanup_xynth},
+    { "xynth", CAIRO_SURFACE_TYPE_XYNTH, CAIRO_CONTENT_COLOR_ALPHA, 0,
+      create_xynth_surface, cairo_surface_write_to_png, cleanup_xynth},
+#endif
     { NULL }
 };
 
diff -Naur cairo-1.4.2/boilerplate/cairo-test-xynth.c cairo-1.4.2-xynth/boilerplate/cairo-test-xynth.c
--- cairo-1.4.2/boilerplate/cairo-test-xynth.c	1970-01-01 02:00:00.000000000 +0200
+++ cairo-1.4.2-xynth/boilerplate/cairo-test-xynth.c	2007-04-06 18:52:35.000000000 +0300
@@ -0,0 +1,43 @@
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "cairo.h"
+#include "cairo-boilerplate.h"
+#include <xynth.h>
+#include "cairo-xynth.h"
+#include "cairo-test-xynth.h"
+
+typedef struct xynth_boiler_s {
+	cairo_surface_t *surface;
+} xynth_boiler_t;
+
+void cleanup_xynth (void *closure)
+{
+	xynth_boiler_t *xynth;
+	xynth = (xynth_boiler_t *) closure;
+	free(xynth);
+}
+
+cairo_surface_t * create_xynth_surface (const char *name, cairo_content_t content, int width, int height, cairo_boilerplate_mode_t mode, void **closure) 
+{
+	cairo_format_t format;
+	xynth_boiler_t *xynth;
+	xynth = (xynth_boiler_t *) malloc(sizeof(xynth_boiler_t));
+	memset(xynth, 0, sizeof(xynth_boiler_t));
+	if (width <= 0) width = 1;
+	if (height <= 0) height = 1;
+	if (content == CAIRO_CONTENT_COLOR_ALPHA) {
+		format = CAIRO_FORMAT_ARGB32;
+	} else if (content == CAIRO_CONTENT_COLOR) {
+		format = CAIRO_FORMAT_RGB24;
+	} else {
+		free(xynth);
+		return NULL;
+	}
+	*closure = xynth;
+	if (mode == CAIRO_BOILERPLATE_MODE_TEST) {
+		return cairo_xynth_surface_create(width, height, format);
+	} else if (mode == CAIRO_BOILERPLATE_MODE_PERF) {
+	}
+	return NULL;
+}
diff -Naur cairo-1.4.2/boilerplate/cairo-test-xynth.h cairo-1.4.2-xynth/boilerplate/cairo-test-xynth.h
--- cairo-1.4.2/boilerplate/cairo-test-xynth.h	1970-01-01 02:00:00.000000000 +0200
+++ cairo-1.4.2-xynth/boilerplate/cairo-test-xynth.h	2007-04-06 18:53:20.000000000 +0300
@@ -0,0 +1,9 @@
+
+#include <cairo.h>
+
+CAIRO_BEGIN_DECLS
+
+extern void cleanup_xynth (void *closure);
+extern cairo_surface_t * create_xynth_surface (const char *name, cairo_content_t content, int width, int height, cairo_boilerplate_mode_t mode, void **closure); 
+
+CAIRO_END_DECLS
diff -Naur cairo-1.4.2/configure.in cairo-1.4.2-xynth/configure.in
--- cairo-1.4.2/configure.in	2007-03-20 08:23:49.000000000 +0200
+++ cairo-1.4.2-xynth/configure.in	2007-03-30 11:09:54.000000000 +0300
@@ -226,6 +226,14 @@
 
 dnl ===========================================================================
 
+CAIRO_BACKEND_ENABLE(xynth, xynth, xynth, XYNTH_SURFACE, auto, [
+  xynth_REQUIRES=xynth
+  PKG_CHECK_MODULES(xynth, $xynth_REQUIRES, , AC_MSG_RESULT(no)
+		    [use_xynth="no (requires xynth http://www.xynth.org)"])
+])
+
+dnl ===========================================================================
+
 CAIRO_BACKEND_ENABLE(xlib, Xlib, xlib, XLIB_SURFACE, auto, [
   xlib_REQUIRES="x11"
   PKG_CHECK_MODULES(xlib, $xlib_REQUIRES, ,
@@ -894,6 +902,7 @@
 echo "  glitz:         $use_glitz"
 echo "  BeOS:          $use_beos"
 echo "  DirectFB:      $use_directfb"
+echo "  Xynth:         $use_xynth"
 echo ""
 echo "the following font backends:"
 echo "  FreeType:      $use_ft"
@@ -957,3 +966,7 @@
 if test x"$use_directfb" = "xyes" ; then
      echo "$WARNING_MESSAGE" | sed 's/@BACKEND@/DirectFB/'
 fi
+
+if test x"$use_xynth" = "xyes" ; then
+     echo "$WARNING_MESSAGE" | sed 's/@BACKEND@/Xynth/'
+fi
diff -Naur cairo-1.4.2/perf/cairo-perf.c cairo-1.4.2-xynth/perf/cairo-perf.c
--- cairo-1.4.2/perf/cairo-perf.c	2007-03-19 22:08:03.000000000 +0200
+++ cairo-1.4.2-xynth/perf/cairo-perf.c	2007-03-30 11:09:54.000000000 +0300
@@ -76,6 +76,7 @@
     case CAIRO_SURFACE_TYPE_WIN32:
     case CAIRO_SURFACE_TYPE_BEOS:
     case CAIRO_SURFACE_TYPE_DIRECTFB:
+    case CAIRO_SURFACE_TYPE_XYNTH:
 #if CAIRO_VERSION_MAJOR > 1 || (CAIRO_VERSION_MAJOR == 1 && CAIRO_VERSION_MINOR > 2)
     case CAIRO_SURFACE_TYPE_OS2:
 #endif
diff -Naur cairo-1.4.2/src/Makefile.am cairo-1.4.2-xynth/src/Makefile.am
--- cairo-1.4.2/src/Makefile.am	2007-03-19 22:08:03.000000000 +0200
+++ cairo-1.4.2-xynth/src/Makefile.am	2007-03-30 11:09:54.000000000 +0300
@@ -113,6 +113,12 @@
 backend_pkgconfigs += cairo-directfb.pc
 endif
 
+if CAIRO_HAS_XYNTH_SURFACE
+libcairo_xynth_headers = cairo-xynth.h
+libcairo_xynth_sources = cairo-xynth-surface.c
+backend_pkgconfigs += cairo-xynth.pc
+endif
+
 if CAIRO_HAS_FT_FONT
 libcairo_ft_headers = cairo-ft.h
 libcairo_ft_sources = cairo-ft-font.c cairo-ft-private.h
@@ -147,7 +153,8 @@
 	$(libcairo_xcb_headers)		\
 	$(libcairo_xlib_headers)	\
 	$(libcairo_xlib_xrender_headers)	\
-	$(libcairo_directfb_headers)
+	$(libcairo_directfb_headers)	\
+	$(libcairo_xynth_headers)
 
 cairoincludedir = $(includedir)/cairo
 cairoinclude_HEADERS =			\
@@ -237,6 +244,7 @@
 	$(libcairo_win32_sources)		\
 	$(libcairo_os2_sources)			\
 	$(libcairo_directfb_sources)		\
+	$(libcairo_xynth_sources)		\
 	cairoint.h
 
 libcairo_la_LDFLAGS = -version-info @VERSION_INFO@ -no-undefined $(export_symbols)
diff -Naur cairo-1.4.2/src/cairo-image-surface.c cairo-1.4.2-xynth/src/cairo-image-surface.c
--- cairo-1.4.2/src/cairo-image-surface.c	2007-03-19 22:08:03.000000000 +0200
+++ cairo-1.4.2-xynth/src/cairo-image-surface.c	2007-03-30 20:14:46.000000000 +0300
@@ -622,7 +622,7 @@
 {
     *image_out = abstract_surface;
     *image_extra = NULL;
-
+    
     return CAIRO_STATUS_SUCCESS;
 }
 
diff -Naur cairo-1.4.2/src/cairo-xlib-surface.c cairo-1.4.2-xynth/src/cairo-xlib-surface.c
--- cairo-1.4.2/src/cairo-xlib-surface.c	2007-03-20 00:10:33.000000000 +0200
+++ cairo-1.4.2-xynth/src/cairo-xlib-surface.c	2007-03-30 11:09:54.000000000 +0300
@@ -1298,6 +1298,8 @@
     composite_operation_t       operation;
     int				itx, ity;
 
+    printf("composite\n");
+    
     if (!CAIRO_SURFACE_RENDER_HAS_COMPOSITE (dst))
 	return CAIRO_INT_STATUS_UNSUPPORTED;
 
@@ -1331,6 +1333,7 @@
     switch (operation)
     {
     case DO_RENDER:
+    	printf("Render\n");
 	_cairo_xlib_surface_ensure_dst_picture (dst);
 	if (mask) {
 	    status = _cairo_xlib_surface_set_attributes (mask, &mask_attr);
@@ -1364,6 +1367,7 @@
 	break;
 
     case DO_XCOPYAREA:
+    	printf("Copy\n");
 	_cairo_xlib_surface_ensure_gc (dst);
 	XCopyArea (dst->dpy,
 		   src->drawable,
@@ -1376,6 +1380,7 @@
 	break;
 
     case DO_XTILE:
+    	printf("Tile\n");
 	/* This case is only used for bug fallbacks, though it is theoretically
 	 * applicable to the case where we don't have the RENDER extension as
 	 * well.
diff -Naur cairo-1.4.2/src/cairo-xynth-surface.c cairo-1.4.2-xynth/src/cairo-xynth-surface.c
--- cairo-1.4.2/src/cairo-xynth-surface.c	1970-01-01 02:00:00.000000000 +0200
+++ cairo-1.4.2-xynth/src/cairo-xynth-surface.c	2007-04-06 18:44:48.000000000 +0300
@@ -0,0 +1,477 @@
+
+#include <xynth.h>
+
+#include "cairoint.h"
+#include "cairo-xynth.h"
+
+#if 1
+#define DEBUG(fmt...) {\
+	printf(fmt);\
+	printf(" [%s (%s:%d)]\n", __FUNCTION__, __FILE__, __LINE__);\
+}
+#else
+#define DEBUG(fmt...) do { } while (0)
+#endif
+
+#define ENTER() DEBUG("Enter");
+#define LEAVE() DEBUG("Leave");
+#define NIY()   {\
+	DEBUG("Not Implemented Yet");\
+	exit(1);\
+}
+#define ASSERT() {\
+	DEBUG("This should not happen");\
+	assert(0);\
+}
+
+typedef struct cairo_xynth_surface_s {
+	cairo_surface_t cairo;
+	s_render_t *render;
+} cairo_xynth_surface_t;
+
+static S_RENDER_FORMAT _cairo_xynth_format_from_cairo_format (cairo_format_t cairo_format)
+{
+	switch (cairo_format) {
+		case CAIRO_FORMAT_ARGB32:
+			return S_RENDER_FORMAT_ARGB32;
+		case CAIRO_FORMAT_RGB24:
+			return S_RENDER_FORMAT_RGB24;
+		case CAIRO_FORMAT_A8:
+			return S_RENDER_FORMAT_A8;
+		case CAIRO_FORMAT_A1:
+			return S_RENDER_FORMAT_A1;
+	}
+	ASSERT();
+	return S_RENDER_FORMAT_NONE;
+}
+
+static cairo_format_t _cairo_format_from_xynth_format (S_RENDER_FORMAT render_format)
+{
+	switch (render_format) {
+		case S_RENDER_FORMAT_ARGB32:
+			return CAIRO_FORMAT_ARGB32;
+		case S_RENDER_FORMAT_RGB24:
+			return CAIRO_FORMAT_RGB24;
+		case S_RENDER_FORMAT_A8:
+			return CAIRO_FORMAT_A8;
+		case S_RENDER_FORMAT_A1:
+			return CAIRO_FORMAT_A1;
+	}
+	ASSERT();
+	return CAIRO_FORMAT_ARGB32;
+}
+
+static S_RENDER_OPERATOR _cairo_xynth_operator (cairo_operator_t operator)
+{
+	switch (operator) {
+		case CAIRO_OPERATOR_CLEAR:
+			return S_RENDER_OPERATOR_CLEAR;
+		case CAIRO_OPERATOR_SOURCE:
+			return S_RENDER_OPERATOR_SRC;
+		case CAIRO_OPERATOR_OVER:
+			return S_RENDER_OPERATOR_OVER;
+		case CAIRO_OPERATOR_IN:
+			return S_RENDER_OPERATOR_IN;
+		case CAIRO_OPERATOR_OUT:
+			return S_RENDER_OPERATOR_OUT;
+		case CAIRO_OPERATOR_ATOP:
+			return S_RENDER_OPERATOR_ATOP;
+		case CAIRO_OPERATOR_DEST:
+			return S_RENDER_OPERATOR_DST;
+		case CAIRO_OPERATOR_DEST_OVER:
+			return S_RENDER_OPERATOR_OVER_REVERSE;
+		case CAIRO_OPERATOR_DEST_IN:
+			return S_RENDER_OPERATOR_IN_REVERSE;
+		case CAIRO_OPERATOR_DEST_OUT:
+			return S_RENDER_OPERATOR_OUT_REVERSE;
+		case CAIRO_OPERATOR_DEST_ATOP:
+			return S_RENDER_OPERATOR_ATOP_REVERSE;
+		case CAIRO_OPERATOR_XOR:
+			return S_RENDER_OPERATOR_XOR;
+		case CAIRO_OPERATOR_ADD:
+			return S_RENDER_OPERATOR_ADD;
+		case CAIRO_OPERATOR_SATURATE:
+			return S_RENDER_OPERATOR_SATURATE;
+		default:
+			return S_RENDER_OPERATOR_OVER;
+	}
+}
+
+static cairo_surface_t * _cairo_xynth_surface_create_similar (void *abstract_surface, cairo_content_t cairo_content, int width, int height)
+{
+	cairo_surface_t *surface;
+	ENTER();
+	if (!CAIRO_CONTENT_VALID(cairo_content)) {
+		_cairo_error(CAIRO_STATUS_INVALID_CONTENT);
+		surface = NULL;
+	} else {
+		surface = cairo_xynth_surface_create_with_content(cairo_content, width, height);
+	}
+	LEAVE();
+	return surface;
+}
+
+static cairo_status_t  _cairo_xynth_surface_finish (void *abstract_surface)
+{
+	cairo_xynth_surface_t *surface;
+	ENTER();
+	surface = (cairo_xynth_surface_t *) abstract_surface;
+	s_render_uninit(surface->render);
+	LEAVE();
+	return CAIRO_STATUS_SUCCESS;
+}
+
+static cairo_status_t _cairo_xynth_surface_acquire_source_image (void *abstract_surface, cairo_image_surface_t **image_out, void **image_extra)
+{
+	cairo_xynth_surface_t *surface; 	 
+	ENTER();
+	surface = (cairo_xynth_surface_t *) abstract_surface;
+	*image_out = (cairo_image_surface_t *) cairo_image_surface_create_for_data((void *) surface->render->data, _cairo_format_from_xynth_format(surface->render->format), surface->render->width, surface->render->height, surface->render->stride); 	 
+	*image_extra = NULL; 	 
+	DEBUG("(*image_out)->base.status: 0x%08x", (*image_out)->base.status); 	 
+	LEAVE();
+	return 0;
+}
+
+static void _cairo_xynth_surface_release_source_image (void *abstract_surface, cairo_image_surface_t *image, void *image_extra)
+{
+	ENTER();
+	cairo_surface_destroy(&image->base);
+	LEAVE();
+}
+
+static cairo_status_t _cairo_xynth_surface_acquire_dest_image (void *abstract_surface, cairo_rectangle_int16_t *interest_rect, cairo_image_surface_t **image_out, cairo_rectangle_int16_t *image_rect, void **image_extra)
+{
+	ENTER();
+	NIY();
+	LEAVE();
+	return CAIRO_STATUS_SUCCESS;
+}
+
+static void _cairo_xynth_surface_release_dest_image (void *abstract_surface, cairo_rectangle_int16_t *interest_rect, cairo_image_surface_t *image, cairo_rectangle_int16_t *image_rect, void *image_extra)
+{
+	ENTER();
+	NIY();
+	LEAVE();
+}
+
+static cairo_status_t _cairo_xynth_surface_clone_similar (void *abstract_surface, cairo_surface_t *src, int src_x, int src_y, int width, int height, cairo_surface_t **clone_out)
+{
+	s_render_t *tmp;
+	cairo_status_t status;
+	cairo_xynth_surface_t *clone;
+	cairo_xynth_surface_t *surface;
+	ENTER();
+	surface = (cairo_xynth_surface_t *) abstract_surface;
+	if (src->backend == surface->cairo.backend) {
+		*clone_out = cairo_surface_reference(src);
+		status = CAIRO_STATUS_SUCCESS;
+	} else if (_cairo_surface_is_image(src)) {
+		cairo_image_surface_t *image_src = (cairo_image_surface_t *) src;
+		if (!CAIRO_FORMAT_VALID(image_src->format)) {
+			status = CAIRO_INT_STATUS_UNSUPPORTED;
+			goto out;
+		}
+		clone = (cairo_xynth_surface_t *) cairo_xynth_surface_create(image_src->width, image_src->height, image_src->format);
+		if (clone->cairo.status) {
+			status = CAIRO_STATUS_NO_MEMORY;
+			goto out;
+		}
+		s_render_init_for_data(&tmp, image_src->data, _cairo_xynth_format_from_cairo_format(image_src->format), image_src->width, image_src->height, image_src->depth, image_src->stride);
+		s_render_composite(S_RENDER_OPERATOR_SRC, tmp, NULL, clone->render, src_x, src_y, 0, 0, src_x, src_y, width, height);
+		s_render_uninit(tmp);
+		*clone_out = &clone->cairo;
+		status = CAIRO_STATUS_SUCCESS;
+	} else {
+		status = CAIRO_INT_STATUS_UNSUPPORTED;
+	}
+out:
+	LEAVE();
+	return status;
+}
+
+static void _cairo_matrix_to_render_matrix (const cairo_matrix_t *matrix, s_render_matrix_t *render_matrix)
+{
+	static const s_render_matrix_t render_identity_matrix = {{
+		{1 << 16,        0,       0},
+		{       0, 1 << 16,       0},
+		{       0,       0, 1 << 16}
+	}};
+	if (_cairo_matrix_is_identity(matrix)) {
+		*render_matrix = render_identity_matrix;
+	} else {
+		render_matrix->matrix[0][0] = _cairo_fixed_from_double(matrix->xx);
+		render_matrix->matrix[0][1] = _cairo_fixed_from_double(matrix->xy);
+		render_matrix->matrix[0][2] = _cairo_fixed_from_double(matrix->x0);
+		render_matrix->matrix[1][0] = _cairo_fixed_from_double(matrix->yx);
+		render_matrix->matrix[1][1] = _cairo_fixed_from_double(matrix->yy);
+		render_matrix->matrix[1][2] = _cairo_fixed_from_double(matrix->y0);
+		render_matrix->matrix[2][0] = 0;
+		render_matrix->matrix[2][1] = 0;
+		render_matrix->matrix[2][2] = 1 << 16;
+	}
+}
+
+static cairo_status_t _cairo_xynth_surface_set_matrix (cairo_xynth_surface_t *surface, const cairo_matrix_t *matrix)
+{
+	s_render_matrix_t render_matrix;
+	_cairo_matrix_to_render_matrix(matrix, &render_matrix);
+	s_render_set_transform_matrix(surface->render, &render_matrix);
+	return CAIRO_STATUS_SUCCESS;
+}
+
+static cairo_status_t _cairo_xynth_surface_set_filter (cairo_xynth_surface_t *surface, cairo_filter_t filter)
+{
+	S_RENDER_FILTER render_filter;
+	switch (filter) {
+		case CAIRO_FILTER_FAST:
+			render_filter = S_RENDER_FILTER_FAST;
+			break;
+		case CAIRO_FILTER_GOOD:
+			render_filter = S_RENDER_FILTER_GOOD;
+			break;
+		case CAIRO_FILTER_BEST:
+			render_filter = S_RENDER_FILTER_BEST;
+			break;
+		case CAIRO_FILTER_NEAREST:
+			render_filter = S_RENDER_FILTER_NEAREST;
+			break;
+		case CAIRO_FILTER_BILINEAR:
+			render_filter = S_RENDER_FILTER_BILINEAR;
+			break;
+		case CAIRO_FILTER_GAUSSIAN:
+		default:
+			render_filter = S_RENDER_FILTER_BEST;
+	}
+	s_render_set_filter(surface->render, render_filter);
+	return CAIRO_STATUS_SUCCESS;
+}
+
+static cairo_int_status_t _cairo_xynth_surface_set_attributes (cairo_xynth_surface_t *surface, cairo_surface_attributes_t *attributes)
+{
+	cairo_int_status_t status;
+	status = _cairo_xynth_surface_set_matrix(surface, &attributes->matrix);
+	if (status) {
+		return status;
+	}
+	switch (attributes->extend) {
+		case CAIRO_EXTEND_NONE:
+			s_render_set_repeat(surface->render, S_RENDER_REPEAT_NONE);
+			break;
+		case CAIRO_EXTEND_REPEAT:
+			s_render_set_repeat(surface->render, S_RENDER_REPEAT_NORMAL);
+			break;
+		case CAIRO_EXTEND_REFLECT:
+			s_render_set_repeat(surface->render, S_RENDER_REPEAT_REFLECT);
+			break;
+		case CAIRO_EXTEND_PAD:
+			s_render_set_repeat(surface->render, S_RENDER_REPEAT_PAD);
+			break;
+	}
+	status = _cairo_xynth_surface_set_filter(surface, attributes->filter);
+	return status;
+}
+
+static cairo_int_status_t _cairo_xynth_surface_composite (cairo_operator_t cairo_operator, cairo_pattern_t *src_pattern, cairo_pattern_t *mask_pattern, void *abstract_surface, int src_x, int src_y, int mask_x, int mask_y, int dst_x, int dst_y, unsigned int width, unsigned int height)
+{
+	cairo_int_status_t status;
+	cairo_xynth_surface_t *dst;
+	cairo_xynth_surface_t *src;
+	cairo_xynth_surface_t *mask;
+	cairo_surface_attributes_t src_attr;
+	cairo_surface_attributes_t mask_attr;
+	ENTER();
+	dst = (cairo_xynth_surface_t *) abstract_surface;
+	status = _cairo_pattern_acquire_surfaces(src_pattern, mask_pattern, &dst->cairo, src_x, src_y, mask_x, mask_y, width, height, (cairo_surface_t **) &src, (cairo_surface_t **) &mask, &src_attr, &mask_attr);
+	if (status) {
+		return status;
+	}
+	status = _cairo_xynth_surface_set_attributes(src, &src_attr);
+	if (status) {
+		goto out;
+	}
+	if (mask) {
+		status = _cairo_xynth_surface_set_attributes(mask, &mask_attr);
+		if (status) {
+			goto out;
+		}
+		s_render_composite(_cairo_xynth_operator(cairo_operator),
+	                           src->render,
+	                           mask->render,
+	                           dst->render,
+	                           src_x + src_attr.x_offset,
+	                           src_y + src_attr.y_offset,
+	                           mask_x + mask_attr.x_offset,
+	                           mask_y + mask_attr.y_offset,
+	                           dst_x, dst_y,
+	                           width, height);
+	} else {
+		s_render_composite(_cairo_xynth_operator(cairo_operator),
+		                   src->render,
+		                   NULL,
+		                   dst->render,
+		                   src_x + src_attr.x_offset,
+		                   src_y + src_attr.y_offset,
+		                   0, 0,
+		                   dst_x, dst_y,
+		                   width, height);
+	}
+	if (!_cairo_operator_bounded_by_source(cairo_operator)) {
+		status = _cairo_surface_composite_fixup_unbounded(&dst->cairo,
+		                                                  &src_attr, src->render->width, src->render->height,
+		                                                  mask ? &mask_attr : NULL,
+		                                                  mask ? mask->render->width : 0,
+		                                                  mask ? mask->render->height : 0,
+		                                                  src_x, src_y,
+		                                                  mask_x, mask_y,
+		                                                  dst_x, dst_y,
+		                                                  width, height);
+	}
+
+ out:
+ 	if (mask) {
+ 		_cairo_pattern_release_surface(mask_pattern, &mask->cairo, &mask_attr);
+ 	}
+ 	_cairo_pattern_release_surface(src_pattern, &src->cairo, &src_attr);
+	LEAVE();
+	return CAIRO_STATUS_SUCCESS;
+}
+
+static cairo_int_status_t _cairo_xynth_surface_fill_rectangles (void *abstract_surface, cairo_operator_t cairo_operator, const cairo_color_t *cairo_color, cairo_rectangle_int16_t *cairo_rects, int num_rects)
+{
+	int n;
+	s_rect_t *render_rects;
+	s_render_color_t render_color;
+	cairo_xynth_surface_t *surface;
+	ENTER();
+	surface = (cairo_xynth_surface_t *) abstract_surface;
+	render_color.red = cairo_color->red_short;
+	render_color.green = cairo_color->green_short;
+	render_color.blue = cairo_color->blue_short;
+	render_color.alpha = cairo_color->alpha_short;
+	render_rects = (s_rect_t *) malloc(sizeof(s_rect_t) * num_rects);
+	if (render_rects == NULL) {
+		_cairo_error(CAIRO_STATUS_NO_MEMORY);
+		return CAIRO_STATUS_NO_MEMORY;
+	}
+	for (n = 0; n < num_rects; n++) {
+		render_rects[n].x = cairo_rects[n].x;
+		render_rects[n].y = cairo_rects[n].y;
+		render_rects[n].w = cairo_rects[n].width;
+		render_rects[n].h = cairo_rects[n].height;
+	}
+	s_render_fill_rectangles(_cairo_xynth_operator(cairo_operator), surface->render, &render_color, num_rects, render_rects);
+	free(render_rects);		 
+	LEAVE();
+	return CAIRO_STATUS_SUCCESS;
+}
+
+static cairo_int_status_t _cairo_xynth_surface_composite_trapezoids (cairo_operator_t operator, cairo_pattern_t *source, void *abstract_surface, cairo_antialias_t antialias, int src_x, int src_y, int dst_x, int dst_y, unsigned int width, unsigned int height, cairo_trapezoid_t *traps, int num_traps)
+{
+	ENTER();
+	NIY();
+	LEAVE();
+	return 0;
+}
+
+static cairo_int_status_t _cairo_xynth_surface_set_clip_region (void *abstract_surface, pixman_region16_t *region)
+{
+	ENTER();
+	NIY();
+	LEAVE();
+	return CAIRO_STATUS_SUCCESS;
+}
+
+static cairo_int_status_t _cairo_xynth_surface_get_extents (void *abstract_surface, cairo_rectangle_int16_t *rectangle)
+{
+	cairo_xynth_surface_t *surface;
+	ENTER();
+	surface = (cairo_xynth_surface_t *) abstract_surface;
+	rectangle->x = 0;
+	rectangle->y = 0;
+	rectangle->width = surface->render->width;
+	rectangle->height = surface->render->height;
+	LEAVE();
+	return CAIRO_STATUS_SUCCESS;
+}
+
+static cairo_surface_backend_t cairo_xynth_surface_backend = {
+	CAIRO_SURFACE_TYPE_XYNTH,
+	_cairo_xynth_surface_create_similar,
+	_cairo_xynth_surface_finish,
+	_cairo_xynth_surface_acquire_source_image,
+	_cairo_xynth_surface_release_source_image,
+	_cairo_xynth_surface_acquire_dest_image,
+	_cairo_xynth_surface_release_dest_image,
+	_cairo_xynth_surface_clone_similar,
+	_cairo_xynth_surface_composite,
+	_cairo_xynth_surface_fill_rectangles,
+	_cairo_xynth_surface_composite_trapezoids,
+	NULL, //_cairo_xynth_surface_copy_page,
+	NULL, //_cairo_xynth_surface_show_page,
+	_cairo_xynth_surface_set_clip_region,
+	NULL, //_cairo_xynth_surface_intersect_clip_path,
+	_cairo_xynth_surface_get_extents,
+	NULL, //_cairo_xynth_surface_old_show_glyphs,
+	NULL, //_cairo_xynth_surface_get_font_options,
+	NULL, //_cairo_xynth_surface_flush,
+	NULL, //_cairo_xynth_surface_mark_dirty_rectangle,
+	NULL, //_cairo_xynth_surface_scaled_font_fini,
+	NULL, //_cairo_xynth_surface_scaled_glyph_fini,
+	NULL, //_cairo_xynth_surface_paint,
+	NULL, //_cairo_xynth_surface_mask,
+	NULL, //_cairo_xynth_surface_stroke,
+	NULL, //_cairo_xynth_surface_fill,
+	NULL, //_cairo_xynth_surface_show_glyphs,
+	NULL, //_cairo_xynth_surface_snapshot,
+};
+
+cairo_surface_t * cairo_xynth_surface_create (unsigned int width, unsigned int height, cairo_format_t cairo_format)
+{
+	S_RENDER_FORMAT render_format;
+	cairo_xynth_surface_t *surface;
+	ENTER();
+	if (!CAIRO_FORMAT_VALID(cairo_format)) {
+		_cairo_error(CAIRO_STATUS_INVALID_FORMAT);
+		return NULL;
+	}
+	render_format = _cairo_xynth_format_from_cairo_format(cairo_format);
+	if (render_format == S_RENDER_FORMAT_NONE) {
+		_cairo_error(CAIRO_STATUS_INVALID_FORMAT);
+		return NULL;
+	}
+	
+	surface = (cairo_xynth_surface_t *) malloc(sizeof(cairo_xynth_surface_t));
+	if (surface == NULL) {
+		_cairo_error(CAIRO_STATUS_NO_MEMORY);
+		return NULL;
+	}
+	memset(surface, 0, sizeof(cairo_xynth_surface_t));
+	
+	if (s_render_init(&surface->render, render_format, width, height)) {
+		free(surface);
+		_cairo_error(CAIRO_STATUS_NO_MEMORY);
+		return NULL;
+	}
+	_cairo_surface_init(&surface->cairo, &cairo_xynth_surface_backend, _cairo_content_from_format(cairo_format));
+	LEAVE();
+	return &surface->cairo;
+}
+
+cairo_surface_t * cairo_xynth_surface_create_with_content (cairo_content_t content, int width, int height)
+{
+	cairo_surface_t *surface;
+	ENTER();
+	if (! CAIRO_CONTENT_VALID(content)) {
+		surface = NULL;
+	} else {
+		surface = cairo_xynth_surface_create( width, height, _cairo_format_from_content(content));
+	}
+	LEAVE();
+	return surface;
+}
+
+cairo_bool_t _cairo_surface_is_xynth (const cairo_surface_t *surface)
+{
+	return surface->backend == &cairo_xynth_surface_backend;
+}
diff -Naur cairo-1.4.2/src/cairo-xynth.h cairo-1.4.2-xynth/src/cairo-xynth.h
--- cairo-1.4.2/src/cairo-xynth.h	1970-01-01 02:00:00.000000000 +0200
+++ cairo-1.4.2-xynth/src/cairo-xynth.h	2007-04-06 16:24:22.000000000 +0300
@@ -0,0 +1,3 @@
+
+cairo_surface_t * cairo_xynth_surface_create (unsigned int width, unsigned int height, cairo_format_t cairo_format);
+cairo_surface_t * cairo_xynth_surface_create_with_content (cairo_content_t content, int width, int height);
diff -Naur cairo-1.4.2/src/cairo.h cairo-1.4.2-xynth/src/cairo.h
--- cairo-1.4.2/src/cairo.h	2007-03-19 22:08:04.000000000 +0200
+++ cairo-1.4.2-xynth/src/cairo.h	2007-03-30 11:09:54.000000000 +0300
@@ -1435,6 +1435,7 @@
  * @CAIRO_SURFACE_TYPE_DIRECTFB: The surface is of type directfb
  * @CAIRO_SURFACE_TYPE_SVG: The surface is of type svg
  * @CAIRO_SURFACE_TYPE_OS2: The surface is of type os2
+ * @CAIRO_SURFACE_TYPE_XYNTH: The surface if of type xynth
  *
  * #cairo_surface_type_t is used to describe the type of a given
  * surface. The surface types are also known as "backends" or "surface
@@ -1471,7 +1472,8 @@
     CAIRO_SURFACE_TYPE_BEOS,
     CAIRO_SURFACE_TYPE_DIRECTFB,
     CAIRO_SURFACE_TYPE_SVG,
-    CAIRO_SURFACE_TYPE_OS2
+    CAIRO_SURFACE_TYPE_OS2,
+    CAIRO_SURFACE_TYPE_XYNTH
 } cairo_surface_type_t;
 
 cairo_public cairo_surface_type_t
diff -Naur cairo-1.4.2/src/cairoint.h cairo-1.4.2-xynth/src/cairoint.h
--- cairo-1.4.2/src/cairoint.h	2007-03-19 22:08:04.000000000 +0200
+++ cairo-1.4.2-xynth/src/cairoint.h	2007-03-30 20:09:35.000000000 +0300
@@ -2233,6 +2233,9 @@
 _cairo_surface_is_image (const cairo_surface_t *surface);
 
 cairo_private cairo_bool_t
+_cairo_surface_is_xynth (const cairo_surface_t *surface);
+
+cairo_private cairo_bool_t
 _cairo_surface_is_meta (const cairo_surface_t *surface);
 
 /* cairo_pen.c */
diff -Naur cairo-1.4.2/test/buffer-diff.c cairo-1.4.2-xynth/test/buffer-diff.c
--- cairo-1.4.2/test/buffer-diff.c	2007-03-19 22:08:04.000000000 +0200
+++ cairo-1.4.2-xynth/test/buffer-diff.c	2007-03-30 11:09:54.000000000 +0300
@@ -149,6 +149,8 @@
     cairo_test_log ("%d pixels differ (with maximum difference of %d) from reference image\n",
 		    result->pixels_changed, result->max_diff);
 
+    return;
+
     /* Then, if there are any different pixels, we give the pdiff code
      * a crack at the images. If it decides that there are no visually
      * discernible differences in any pixels, then we accept this
diff -Naur cairo-1.4.2/test/get-clip.c cairo-1.4.2-xynth/test/get-clip.c
--- cairo-1.4.2/test/get-clip.c	2007-03-19 22:08:04.000000000 +0200
+++ cairo-1.4.2-xynth/test/get-clip.c	2007-03-30 11:09:54.000000000 +0300
@@ -138,6 +138,7 @@
     case CAIRO_SURFACE_TYPE_WIN32:
     case CAIRO_SURFACE_TYPE_BEOS:
     case CAIRO_SURFACE_TYPE_DIRECTFB:
+    case CAIRO_SURFACE_TYPE_XYNTH:
         uses_clip_rects = TRUE;
 	break;
     case CAIRO_SURFACE_TYPE_QUARTZ:
